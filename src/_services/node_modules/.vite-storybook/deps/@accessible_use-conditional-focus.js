import {
  module_default
} from "./chunk-BQD24JIE.js";
import {
  require_react
} from "./chunk-TW7ERABM.js";
import "./chunk-ONM5EPDC.js";
import {
  __toESM,
  init_define_import_meta_env
} from "./chunk-CCD2FOVN.js";

// dep:@accessible_use-conditional-focus
init_define_import_meta_env();

// node_modules/@accessible/use-conditional-focus/dist/module/index.js
init_define_import_meta_env();
var React = __toESM(require_react());

// node_modules/@accessible/tabbable/dist/module/index.js
init_define_import_meta_env();
var candidateSelector = 'input,select,textarea,a[href],button,[tabindex],audio[controls],video[controls],[contenteditable]:not([contenteditable="false"])';
var matches = typeof Element === "undefined" ? () => false : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
function _ref(a) {
  return a.node;
}
var tabbable = (el, includeRootNode = false) => {
  const regularTabbables = [];
  const orderedTabbables = [];
  let candidates = el.querySelectorAll(candidateSelector);
  if (includeRootNode && matches.call(el, candidateSelector)) {
    candidates = Array.prototype.slice.apply(candidates);
    candidates.unshift(el);
  }
  let i, candidate, candidateTabindex;
  for (i = 0; i < candidates.length; i++) {
    candidate = candidates[i];
    if (!isNodeMatchingSelectorTabbable(candidate))
      continue;
    candidateTabindex = getTabindex(candidate);
    if (candidateTabindex === 0) {
      regularTabbables.push(candidate);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        node: candidate
      });
    }
  }
  return orderedTabbables.sort(sortOrderedTabbables).map(_ref).concat(regularTabbables);
};
var isNodeMatchingSelectorTabbable = (node) => !(!isNodeMatchingSelectorFocusable(node) || node.tagName === "INPUT" && node.type === "radio" && !isTabbableRadio(node) || getTabindex(node) < 0);
var isNodeMatchingSelectorFocusable = (node) => !(node.disabled || isInput(node) && node.type === "hidden" || node.offsetParent === null || getComputedStyle(node).visibility === "hidden");
var getTabindex = (node) => {
  const tabindexAttr = parseInt(node.getAttribute("tabindex") || "", 10);
  if (!isNaN(tabindexAttr))
    return tabindexAttr;
  if (node.contentEditable === "true")
    return 0;
  return node.tabIndex;
};
var sortOrderedTabbables = (a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
var isInput = (node) => node.tagName === "INPUT";
var isTabbableRadio = (node) => {
  if (!node.name)
    return true;
  if (node.ownerDocument) {
    const radioSet = node.ownerDocument.querySelectorAll('input[type="radio"][name="' + node.name + '"]');
    for (let i = 0; i < radioSet.length; i++)
      if (radioSet[i].checked)
        return radioSet[i] === node;
    return true;
  }
  return false;
};
var module_default2 = tabbable;

// node_modules/@accessible/use-conditional-focus/dist/module/index.js
function useConditionalFocus(target, shouldFocus = false, {
  includeRoot,
  preventScroll
} = defaultOptions) {
  const didFocus = React.useRef(false);
  const didFocusAfterEvent = React.useRef(false);
  React.useEffect(() => {
    const element = target && "current" in target ? target.current : target;
    if (!element || !shouldFocus || didFocus.current)
      return;
    const tabbableEls = module_default2(element, includeRoot);
    if (tabbableEls.length > 0)
      tabbableEls[0].focus({
        preventScroll
      });
    didFocus.current = true;
  }, [target, includeRoot, preventScroll, shouldFocus]);
  function _ref2() {
    didFocus.current = false;
    didFocusAfterEvent.current = false;
  }
  React.useEffect(() => {
    return _ref2;
  }, [shouldFocus]);
  module_default(target, "transitionend", () => {
    const element = target && "current" in target ? target.current : target;
    if (!element || !shouldFocus || didFocusAfterEvent.current)
      return;
    const tabbableEls = module_default2(element, includeRoot);
    if (tabbableEls.length > 0)
      tabbableEls[0].focus({
        preventScroll
      });
    didFocusAfterEvent.current = true;
  });
}
var defaultOptions = {
  includeRoot: false,
  preventScroll: false
};
var module_default3 = useConditionalFocus;

// dep:@accessible_use-conditional-focus
var accessible_use_conditional_focus_default = module_default3;
export {
  accessible_use_conditional_focus_default as default
};
//# sourceMappingURL=@accessible_use-conditional-focus.js.map
