{
  "version": 3,
  "sources": ["dep:@accessible_use-conditional-focus", "../../../../../node_modules/@accessible/use-conditional-focus/dist/module/index.js", "../../../../../node_modules/@accessible/tabbable/dist/module/index.js"],
  "sourcesContent": ["import d from \"../../node_modules/@accessible/use-conditional-focus/dist/module/index.js\";export default d;", "import * as React from 'react';\nimport tabbable from '@accessible/tabbable';\nimport useEvent from '@react-hook/event';\n\nfunction useConditionalFocus(target, shouldFocus = false, {\n  includeRoot,\n  preventScroll\n} = defaultOptions) {\n  const didFocus = React.useRef(false);\n  const didFocusAfterEvent = React.useRef(false);\n  React.useEffect(() => {\n    const element = target && 'current' in target ? target.current : target;\n    if (!element || !shouldFocus || didFocus.current) return;\n    const tabbableEls = tabbable(element, includeRoot);\n    if (tabbableEls.length > 0) tabbableEls[0].focus({\n      preventScroll\n    });\n    didFocus.current = true;\n  }, [target, includeRoot, preventScroll, shouldFocus]);\n\n  function _ref() {\n    didFocus.current = false;\n    didFocusAfterEvent.current = false;\n  }\n\n  React.useEffect(() => {\n    return _ref;\n  }, [shouldFocus]);\n  useEvent(target, 'transitionend', () => {\n    const element = target && 'current' in target ? target.current : target;\n    if (!element || !shouldFocus || didFocusAfterEvent.current) return;\n    const tabbableEls = tabbable(element, includeRoot);\n    if (tabbableEls.length > 0) tabbableEls[0].focus({\n      preventScroll\n    });\n    didFocusAfterEvent.current = true;\n  });\n}\n\nconst defaultOptions = {\n  includeRoot: false,\n  preventScroll: false\n};\nexport default useConditionalFocus;", "// Credit:\n// https://github.com/davidtheclark/tabbable\nconst candidateSelector = 'input,select,textarea,a[href],button,[tabindex],' + 'audio[controls],video[controls],' + '[contenteditable]:not([contenteditable=\"false\"])';\nconst matches = typeof Element === 'undefined' ? () => false : Element.prototype.matches || // @ts-ignore\nElement.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction _ref(a) {\n  return a.node;\n}\n\nconst tabbable = (el, includeRootNode = false) => {\n  const regularTabbables = [];\n  const orderedTabbables = [];\n  let candidates = el.querySelectorAll(candidateSelector);\n\n  if (includeRootNode && matches.call(el, candidateSelector)) {\n    candidates = Array.prototype.slice.apply(candidates);\n    candidates.unshift(el);\n  }\n\n  let i, candidate, candidateTabindex;\n\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n    if (!isNodeMatchingSelectorTabbable(candidate)) continue;\n    candidateTabindex = getTabindex(candidate);\n\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate\n      });\n    }\n  }\n\n  return orderedTabbables.sort(sortOrderedTabbables).map(_ref).concat(regularTabbables);\n};\n\nconst isNodeMatchingSelectorTabbable = node => !(!isNodeMatchingSelectorFocusable(node) || node.tagName === 'INPUT' && node.type === 'radio' && !isTabbableRadio(node) || getTabindex(node) < 0);\n\nconst isNodeMatchingSelectorFocusable = node => !(node.disabled || isInput(node) && node.type === 'hidden' || // offsetParent being null will allow detecting cases where an element\n// is invisible or inside an invisible element,  as long as the element\n// does not use position: fixed. For them, their visibility has to be\n// checked directly as well.\nnode.offsetParent === null || getComputedStyle(node).visibility === 'hidden');\n\nconst getTabindex = node => {\n  const tabindexAttr = parseInt(node.getAttribute('tabindex') || '', 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr; // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n\n  if (node.contentEditable === 'true') return 0;\n  return node.tabIndex;\n}; // @ts-ignore\n\n\nconst sortOrderedTabbables = (a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n\nconst isInput = node => node.tagName === 'INPUT';\n\nconst isTabbableRadio = node => {\n  if (!node.name) return true; // This won't account for the edge case where you have radio groups with the\n  // same in separate forms on the same page.\n\n  if (node.ownerDocument) {\n    const radioSet = node.ownerDocument.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n\n    for (let i = 0; i < radioSet.length; i++) if (radioSet[i].checked) return radioSet[i] === node;\n\n    return true;\n  }\n\n  return false;\n};\n\nexport default tabbable;"],
  "mappings": "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",
  "names": []
}
