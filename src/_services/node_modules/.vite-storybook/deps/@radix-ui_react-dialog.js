import {
  createContext,
  createContextScope,
  useId,
  useLayoutEffect
} from "./chunk-TGFTHYGE.js";
import {
  Primitive,
  Slot,
  composeEventHandlers,
  useCallbackRef,
  useComposedRefs,
  useControllableState
} from "./chunk-2I4RMD4V.js";
import {
  __assign,
  __rest,
  __spreadArray
} from "./chunk-LMJPPDMQ.js";
import {
  require_react_dom
} from "./chunk-NJ7GDN7X.js";
import {
  _extends,
  init_extends
} from "./chunk-OEZEVKV6.js";
import {
  require_react
} from "./chunk-TW7ERABM.js";
import "./chunk-ONM5EPDC.js";
import {
  __toESM,
  init_define_import_meta_env
} from "./chunk-CCD2FOVN.js";

// dep:@radix-ui_react-dialog
init_define_import_meta_env();

// node_modules/@radix-ui/react-dialog/dist/index.module.js
init_define_import_meta_env();

// node_modules/aria-hidden/dist/es2015/index.js
init_define_import_meta_env();
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (parentNode === void 0) {
    parentNode = getDefaultParent(originalTarget);
  }
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.isArray(originalTarget) ? originalTarget : [originalTarget];
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || targets.indexOf(parent) >= 0) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        var attr = node.getAttribute("aria-hidden");
        var alreadyHidden = attr !== null && attr !== "false";
        var counterValue = (counterMap.get(node) || 0) + 1;
        var markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenNodes.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node, true);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "true");
        }
        if (!alreadyHidden) {
          node.setAttribute("aria-hidden", "true");
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute("aria-hidden");
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};

// node_modules/react-remove-scroll/dist/es2015/index.js
init_define_import_meta_env();

// node_modules/react-remove-scroll/dist/es2015/Combination.js
init_define_import_meta_env();
var React8 = __toESM(require_react());

// node_modules/react-remove-scroll/dist/es2015/UI.js
init_define_import_meta_env();
var React4 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/constants.js
init_define_import_meta_env();
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// node_modules/use-callback-ref/dist/es2015/index.js
init_define_import_meta_env();

// node_modules/use-callback-ref/dist/es2015/assignRef.js
init_define_import_meta_env();
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// node_modules/use-callback-ref/dist/es2015/useRef.js
init_define_import_meta_env();
var import_react = __toESM(require_react());
function useCallbackRef2(initialValue, callback) {
  var ref = (0, import_react.useState)(function() {
    return {
      value: initialValue,
      callback,
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// node_modules/use-callback-ref/dist/es2015/createRef.js
init_define_import_meta_env();

// node_modules/use-callback-ref/dist/es2015/mergeRef.js
init_define_import_meta_env();

// node_modules/use-callback-ref/dist/es2015/useMergeRef.js
init_define_import_meta_env();
function useMergeRefs(refs, defaultValue) {
  return useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
}

// node_modules/use-callback-ref/dist/es2015/useTransformRef.js
init_define_import_meta_env();

// node_modules/use-callback-ref/dist/es2015/transformRef.js
init_define_import_meta_env();

// node_modules/use-callback-ref/dist/es2015/refToCallback.js
init_define_import_meta_env();

// node_modules/react-remove-scroll/dist/es2015/medium.js
init_define_import_meta_env();

// node_modules/use-sidecar/dist/es2015/index.js
init_define_import_meta_env();

// node_modules/use-sidecar/dist/es2015/hoc.js
init_define_import_meta_env();
var React = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/hook.js
init_define_import_meta_env();
var import_react2 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/env.js
init_define_import_meta_env();

// node_modules/detect-node-es/esm/browser.js
init_define_import_meta_env();

// node_modules/use-sidecar/dist/es2015/config.js
init_define_import_meta_env();

// node_modules/use-sidecar/dist/es2015/medium.js
init_define_import_meta_env();
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// node_modules/use-sidecar/dist/es2015/renderProp.js
init_define_import_meta_env();
var React2 = __toESM(require_react());
var import_react3 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/exports.js
init_define_import_meta_env();
var React3 = __toESM(require_react());
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React3.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React4.forwardRef(function(props, parentRef) {
  var ref = React4.useRef(null);
  var _a = React4.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React4.createElement(React4.Fragment, null, enabled && React4.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }), forwardProps ? React4.cloneElement(React4.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React4.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children));
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// node_modules/react-remove-scroll/dist/es2015/sidecar.js
init_define_import_meta_env();

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
init_define_import_meta_env();
var React7 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/index.js
init_define_import_meta_env();

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
init_define_import_meta_env();
var React6 = __toESM(require_react());

// node_modules/react-style-singleton/dist/es2015/index.js
init_define_import_meta_env();

// node_modules/react-style-singleton/dist/es2015/component.js
init_define_import_meta_env();

// node_modules/react-style-singleton/dist/es2015/hook.js
init_define_import_meta_env();
var React5 = __toESM(require_react());

// node_modules/react-style-singleton/dist/es2015/singleton.js
init_define_import_meta_env();

// node_modules/get-nonce/dist/es2015/index.js
init_define_import_meta_env();
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React5.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// node_modules/react-remove-scroll-bar/dist/es2015/utils.js
init_define_import_meta_env();
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  if (true) {
    if (cs.overflowY === "hidden") {
      console.error("react-remove-scroll-bar: cannot calculate scrollbar size because it is removed (overflow:hidden on body");
    }
  }
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var RemoveScrollBar = function(props) {
  var noRelative = props.noRelative, noImportant = props.noImportant, _a = props.gapMode, gapMode = _a === void 0 ? "margin" : _a;
  var gap = React6.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React6.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
init_define_import_meta_env();
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// node_modules/react-remove-scroll/dist/es2015/handleScroll.js
init_define_import_meta_env();
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  var styles = window.getComputedStyle(node);
  return styles[overflow] !== "hidden" && !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible");
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), s2 = _a[1], d3 = _a[2];
      if (s2 > d3) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    target = target.parentNode;
  } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x2, y) {
  return x2[0] === y[0] && x2[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React7.useRef([]);
  var touchStartRef = React7.useRef([0, 0]);
  var activeAxis = React7.useRef();
  var id = React7.useState(idCounter++)[0];
  var Style2 = React7.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = React7.useRef(props);
  React7.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React7.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React7.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React7.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e3) {
      return e3.name === event.type && e3.target === event.target && deltaCompare(e3.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React7.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e3) {
        return e3 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React7.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React7.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React7.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React7.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React7.createElement(React7.Fragment, null, inert ? React7.createElement(Style2, { styles: generateStyle(id) }) : null, removeScrollBar ? React7.createElement(RemoveScrollBar, { gapMode: "margin" }) : null);
}

// node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React8.forwardRef(function(props, ref) {
  return React8.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// node_modules/@radix-ui/react-focus-guards/dist/index.module.js
init_define_import_meta_env();
var e = __toESM(require_react());
var t = 0;
function useFocusGuards() {
  e.useEffect(() => {
    var e3, n2;
    const r4 = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", null !== (e3 = r4[0]) && void 0 !== e3 ? e3 : o()), document.body.insertAdjacentElement("beforeend", null !== (n2 = r4[1]) && void 0 !== n2 ? n2 : o()), t++, () => {
      1 === t && document.querySelectorAll("[data-radix-focus-guard]").forEach((e4) => e4.remove()), t--;
    };
  }, []);
}
function o() {
  const e3 = document.createElement("span");
  return e3.setAttribute("data-radix-focus-guard", ""), e3.tabIndex = 0, e3.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", e3;
}

// node_modules/@radix-ui/react-presence/dist/index.module.js
init_define_import_meta_env();
var t2 = __toESM(require_react());
var Presence = (u2) => {
  const { present: o4, children: i3 } = u2, s2 = function(n2) {
    const [u3, o5] = t2.useState(), i4 = t2.useRef({}), s3 = t2.useRef(n2), c4 = t2.useRef("none"), a3 = n2 ? "mounted" : "unmounted", [d3, m2] = function(e3, n3) {
      return t2.useReducer((e4, t5) => {
        const r4 = n3[e4][t5];
        return null != r4 ? r4 : e4;
      }, e3);
    }(a3, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } });
    return t2.useEffect(() => {
      const e3 = r(i4.current);
      c4.current = "mounted" === d3 ? e3 : "none";
    }, [d3]), useLayoutEffect(() => {
      const e3 = i4.current, t5 = s3.current;
      if (t5 !== n2) {
        const u4 = c4.current, o6 = r(e3);
        if (n2)
          m2("MOUNT");
        else if ("none" === o6 || "none" === (null == e3 ? void 0 : e3.display))
          m2("UNMOUNT");
        else {
          const e4 = u4 !== o6;
          m2(t5 && e4 ? "ANIMATION_OUT" : "UNMOUNT");
        }
        s3.current = n2;
      }
    }, [n2, m2]), useLayoutEffect(() => {
      if (u3) {
        const e3 = (e4) => {
          const n4 = r(i4.current).includes(e4.animationName);
          e4.target === u3 && n4 && m2("ANIMATION_END");
        }, n3 = (e4) => {
          e4.target === u3 && (c4.current = r(i4.current));
        };
        return u3.addEventListener("animationstart", n3), u3.addEventListener("animationcancel", e3), u3.addEventListener("animationend", e3), () => {
          u3.removeEventListener("animationstart", n3), u3.removeEventListener("animationcancel", e3), u3.removeEventListener("animationend", e3);
        };
      }
      m2("ANIMATION_END");
    }, [u3, m2]), { isPresent: ["mounted", "unmountSuspended"].includes(d3), ref: t2.useCallback((e3) => {
      e3 && (i4.current = getComputedStyle(e3)), o5(e3);
    }, []) };
  }(o4), c3 = "function" == typeof i3 ? i3({ present: s2.isPresent }) : t2.Children.only(i3), a2 = useComposedRefs(s2.ref, c3.ref);
  return "function" == typeof i3 || s2.isPresent ? t2.cloneElement(c3, { ref: a2 }) : null;
};
function r(e3) {
  return (null == e3 ? void 0 : e3.animationName) || "none";
}
Presence.displayName = "Presence";

// node_modules/@radix-ui/react-portal/dist/index.module.js
init_define_import_meta_env();
var import_react_dom = __toESM(require_react_dom());
var r2 = __toESM(require_react());
init_extends();
var Portal = r2.forwardRef((a2, i3) => {
  var n2, d3;
  const { containerRef: s2, style: u2, ...c3 } = a2, m2 = null !== (n2 = null == s2 ? void 0 : s2.current) && void 0 !== n2 ? n2 : null === globalThis || void 0 === globalThis || null === (d3 = globalThis.document) || void 0 === d3 ? void 0 : d3.body, [, f2] = r2.useState({});
  return useLayoutEffect(() => {
    f2({});
  }, []), m2 ? import_react_dom.default.createPortal(r2.createElement(Primitive.div, _extends({ "data-radix-portal": "" }, c3, { ref: i3, style: m2 === document.body ? { position: "absolute", top: 0, left: 0, zIndex: 2147483647, ...u2 } : void 0 })), m2) : null;
});
var UnstablePortal = r2.forwardRef((t5, a2) => {
  var i3;
  const { container: n2 = null === globalThis || void 0 === globalThis || null === (i3 = globalThis.document) || void 0 === i3 ? void 0 : i3.body, ...d3 } = t5;
  return n2 ? import_react_dom.default.createPortal(r2.createElement(Primitive.div, _extends({}, d3, { ref: a2 })), n2) : null;
});

// node_modules/@radix-ui/react-focus-scope/dist/index.module.js
init_define_import_meta_env();
var o2 = __toESM(require_react());
init_extends();
var c = { bubbles: false, cancelable: true };
var FocusScope = o2.forwardRef((i3, f2) => {
  const { loop: l = false, trapped: m2 = false, onMountAutoFocus: p, onUnmountAutoFocus: v2, ...E2 } = i3, [F2, S] = o2.useState(null), b2 = useCallbackRef(p), T = useCallbackRef(v2), y = o2.useRef(null), L = useComposedRefs(f2, (e3) => S(e3)), h2 = o2.useRef({ paused: false, pause() {
    this.paused = true;
  }, resume() {
    this.paused = false;
  } }).current;
  o2.useEffect(() => {
    if (m2) {
      let e3 = function(e4) {
        if (h2.paused || !F2)
          return;
        const t6 = e4.target;
        F2.contains(t6) ? y.current = t6 : a(y.current, { select: true });
      }, t5 = function(e4) {
        !h2.paused && F2 && (F2.contains(e4.relatedTarget) || a(y.current, { select: true }));
      };
      return document.addEventListener("focusin", e3), document.addEventListener("focusout", t5), () => {
        document.removeEventListener("focusin", e3), document.removeEventListener("focusout", t5);
      };
    }
  }, [m2, F2, h2.paused]), o2.useEffect(() => {
    if (F2) {
      d.add(h2);
      const t5 = document.activeElement;
      if (!F2.contains(t5)) {
        const n2 = new Event("focusScope.autoFocusOnMount", c);
        F2.addEventListener("focusScope.autoFocusOnMount", b2), F2.dispatchEvent(n2), n2.defaultPrevented || (!function(e4, { select: t6 = false } = {}) {
          const n3 = document.activeElement;
          for (const o4 of e4)
            if (a(o4, { select: t6 }), document.activeElement !== n3)
              return;
        }((e3 = r3(F2), e3.filter((e4) => "A" !== e4.tagName)), { select: true }), document.activeElement === t5 && a(F2));
      }
      return () => {
        F2.removeEventListener("focusScope.autoFocusOnMount", b2), setTimeout(() => {
          const e4 = new Event("focusScope.autoFocusOnUnmount", c);
          F2.addEventListener("focusScope.autoFocusOnUnmount", T), F2.dispatchEvent(e4), e4.defaultPrevented || a(null != t5 ? t5 : document.body, { select: true }), F2.removeEventListener("focusScope.autoFocusOnUnmount", T), d.remove(h2);
        }, 0);
      };
    }
    var e3;
  }, [F2, b2, T, h2]);
  const N = o2.useCallback((e3) => {
    if (!l && !m2)
      return;
    if (h2.paused)
      return;
    const t5 = "Tab" === e3.key && !e3.altKey && !e3.ctrlKey && !e3.metaKey, n2 = document.activeElement;
    if (t5 && n2) {
      const t6 = e3.currentTarget, [o4, u2] = function(e4) {
        const t7 = r3(e4), n3 = s(t7, e4), o5 = s(t7.reverse(), e4);
        return [n3, o5];
      }(t6);
      o4 && u2 ? e3.shiftKey || n2 !== u2 ? e3.shiftKey && n2 === o4 && (e3.preventDefault(), l && a(u2, { select: true })) : (e3.preventDefault(), l && a(o4, { select: true })) : n2 === t6 && e3.preventDefault();
    }
  }, [l, m2, h2.paused]);
  return o2.createElement(Primitive.div, _extends({ tabIndex: -1 }, E2, { ref: L, onKeyDown: N }));
});
function r3(e3) {
  const t5 = [], n2 = document.createTreeWalker(e3, NodeFilter.SHOW_ELEMENT, { acceptNode: (e4) => {
    const t6 = "INPUT" === e4.tagName && "hidden" === e4.type;
    return e4.disabled || e4.hidden || t6 ? NodeFilter.FILTER_SKIP : e4.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  for (; n2.nextNode(); )
    t5.push(n2.currentNode);
  return t5;
}
function s(e3, t5) {
  for (const n2 of e3)
    if (!i(n2, { upTo: t5 }))
      return n2;
}
function i(e3, { upTo: t5 }) {
  if ("hidden" === getComputedStyle(e3).visibility)
    return true;
  for (; e3; ) {
    if (void 0 !== t5 && e3 === t5)
      return false;
    if ("none" === getComputedStyle(e3).display)
      return true;
    e3 = e3.parentElement;
  }
  return false;
}
function a(e3, { select: t5 = false } = {}) {
  if (e3 && e3.focus) {
    const n2 = document.activeElement;
    e3.focus({ preventScroll: true }), e3 !== n2 && function(e4) {
      return e4 instanceof HTMLInputElement && "select" in e4;
    }(e3) && t5 && e3.select();
  }
}
var d = function() {
  let e3 = [];
  return { add(t5) {
    const n2 = e3[0];
    t5 !== n2 && (null == n2 || n2.pause()), e3 = f(e3, t5), e3.unshift(t5);
  }, remove(t5) {
    var n2;
    e3 = f(e3, t5), null === (n2 = e3[0]) || void 0 === n2 || n2.resume();
  } };
}();
function f(e3, t5) {
  const n2 = [...e3], o4 = n2.indexOf(t5);
  return -1 !== o4 && n2.splice(o4, 1), n2;
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.module.js
init_define_import_meta_env();

// node_modules/@radix-ui/react-use-escape-keydown/dist/index.module.js
init_define_import_meta_env();
var t3 = __toESM(require_react());
function useEscapeKeydown(n2) {
  const o4 = useCallbackRef(n2);
  t3.useEffect(() => {
    const e3 = (e4) => {
      "Escape" === e4.key && o4(e4);
    };
    return document.addEventListener("keydown", e3), () => document.removeEventListener("keydown", e3);
  }, [o4]);
}

// node_modules/@radix-ui/react-use-body-pointer-events/dist/index.module.js
init_define_import_meta_env();
var t4 = __toESM(require_react());
var n;
var o3 = 0;
function useBodyPointerEvents({ disabled: r4 }) {
  const i3 = t4.useRef(false);
  useLayoutEffect(() => {
    if (r4) {
      let e3 = function() {
        o3--, 0 === o3 && (document.body.style.pointerEvents = n);
      }, t5 = function(e4) {
        i3.current = "mouse" !== e4.pointerType;
      };
      return 0 === o3 && (n = document.body.style.pointerEvents), document.body.style.pointerEvents = "none", o3++, document.addEventListener("pointerup", t5), () => {
        i3.current ? document.addEventListener("click", e3, { once: true }) : e3(), document.removeEventListener("pointerup", t5);
      };
    }
  }, [r4]);
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.module.js
var i2 = __toESM(require_react());
init_extends();
var u = i2.createContext({ layers: /* @__PURE__ */ new Set(), layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(), branches: /* @__PURE__ */ new Set() });
var DismissableLayer = i2.forwardRef((l, m2) => {
  const { disableOutsidePointerEvents: f2 = false, onEscapeKeyDown: p, onPointerDownOutside: v2, onFocusOutside: b2, onInteractOutside: E2, onDismiss: y, ...w2 } = l, h2 = i2.useContext(u), [D, x2] = i2.useState(null), [, C2] = i2.useState({}), L = useComposedRefs(m2, (e3) => x2(e3)), P = Array.from(h2.layers), [O2] = [...h2.layersWithOutsidePointerEventsDisabled].slice(-1), g = P.indexOf(O2), B = D ? P.indexOf(D) : -1, R2 = h2.layersWithOutsidePointerEventsDisabled.size > 0, F2 = B >= g, S = function(e3) {
    const n2 = useCallbackRef(e3), r4 = i2.useRef(false);
    return i2.useEffect(() => {
      const e4 = (e5) => {
        if (e5.target && !r4.current) {
          d2("dismissableLayer.pointerDownOutside", n2, { originalEvent: e5 });
        }
        r4.current = false;
      }, t5 = window.setTimeout(() => {
        document.addEventListener("pointerdown", e4);
      }, 0);
      return () => {
        window.clearTimeout(t5), document.removeEventListener("pointerdown", e4);
      };
    }, [n2]), { onPointerDownCapture: () => r4.current = true };
  }((e3) => {
    const t5 = e3.target, n2 = [...h2.branches].some((e4) => e4.contains(t5));
    F2 && !n2 && (null == v2 || v2(e3), null == E2 || E2(e3), e3.defaultPrevented || null == y || y());
  }), W = function(e3) {
    const n2 = useCallbackRef(e3), r4 = i2.useRef(false);
    return i2.useEffect(() => {
      const e4 = (e5) => {
        if (e5.target && !r4.current) {
          d2("dismissableLayer.focusOutside", n2, { originalEvent: e5 });
        }
      };
      return document.addEventListener("focusin", e4), () => document.removeEventListener("focusin", e4);
    }, [n2]), { onFocusCapture: () => r4.current = true, onBlurCapture: () => r4.current = false };
  }((e3) => {
    const t5 = e3.target;
    [...h2.branches].some((e4) => e4.contains(t5)) || (null == b2 || b2(e3), null == E2 || E2(e3), e3.defaultPrevented || null == y || y());
  });
  return useEscapeKeydown((e3) => {
    B === h2.layers.size - 1 && (null == p || p(e3), e3.defaultPrevented || null == y || y());
  }), useBodyPointerEvents({ disabled: f2 }), i2.useEffect(() => {
    D && (f2 && h2.layersWithOutsidePointerEventsDisabled.add(D), h2.layers.add(D), c2());
  }, [D, f2, h2]), i2.useEffect(() => () => {
    D && (h2.layers.delete(D), h2.layersWithOutsidePointerEventsDisabled.delete(D), c2());
  }, [D, h2]), i2.useEffect(() => {
    const e3 = () => C2({});
    return document.addEventListener("dismissableLayer.update", e3), () => document.removeEventListener("dismissableLayer.update", e3);
  }, []), i2.createElement(Primitive.div, _extends({}, w2, { ref: L, style: { pointerEvents: R2 ? F2 ? "auto" : "none" : void 0, ...l.style }, onFocusCapture: composeEventHandlers(l.onFocusCapture, W.onFocusCapture), onBlurCapture: composeEventHandlers(l.onBlurCapture, W.onBlurCapture), onPointerDownCapture: composeEventHandlers(l.onPointerDownCapture, S.onPointerDownCapture) }));
});
var DismissableLayerBranch = i2.forwardRef((e3, t5) => {
  const n2 = i2.useContext(u), o4 = i2.useRef(null), c3 = useComposedRefs(t5, o4);
  return i2.useEffect(() => {
    const e4 = o4.current;
    if (e4)
      return n2.branches.add(e4), () => {
        n2.branches.delete(e4);
      };
  }, [n2.branches]), i2.createElement(Primitive.div, _extends({}, e3, { ref: c3 }));
});
function c2() {
  const e3 = new Event("dismissableLayer.update");
  document.dispatchEvent(e3);
}
function d2(e3, t5, n2) {
  const r4 = n2.originalEvent.target, s2 = new CustomEvent(e3, { bubbles: false, cancelable: true, detail: n2 });
  return t5 && r4.addEventListener(e3, t5, { once: true }), !r4.dispatchEvent(s2);
}

// node_modules/@radix-ui/react-dialog/dist/index.module.js
var m = __toESM(require_react());
init_extends();
var [x, C] = createContextScope("Dialog");
var [v, E] = x("Dialog");
var Dialog = (e3) => {
  const { __scopeDialog: o4, children: t5, open: r4, defaultOpen: n2, onOpenChange: a2, modal: i3 = true, allowPinchZoom: l } = e3, c3 = m.useRef(null), p = m.useRef(null), [d3 = false, f2] = useControllableState({ prop: r4, defaultProp: n2, onChange: a2 });
  return m.createElement(v, { scope: o4, triggerRef: c3, contentRef: p, contentId: useId(), titleId: useId(), descriptionId: useId(), open: d3, onOpenChange: f2, onOpenToggle: m.useCallback(() => f2((e4) => !e4), [f2]), modal: i3, allowPinchZoom: l }, t5);
};
var DialogTrigger = m.forwardRef((e3, o4) => {
  const { __scopeDialog: t5, ...r4 } = e3, a2 = E("DialogTrigger", t5), i3 = useComposedRefs(o4, a2.triggerRef);
  return m.createElement(Primitive.button, _extends({ type: "button", "aria-haspopup": "dialog", "aria-expanded": a2.open, "aria-controls": a2.contentId, "data-state": b(a2.open) }, r4, { ref: i3, onClick: composeEventHandlers(e3.onClick, a2.onOpenToggle) }));
});
var DialogPortal = (e3) => {
  const { __scopeDialog: o4, forceMount: t5, children: r4, container: n2 } = e3, l = E("DialogPortal", o4);
  return m.createElement(m.Fragment, null, m.Children.map(r4, (e4) => m.createElement(Presence, { present: t5 || l.open }, m.createElement(UnstablePortal, { asChild: true, container: n2 }, e4))));
};
var DialogOverlay = m.forwardRef((e3, o4) => {
  const { forceMount: t5, ...r4 } = e3, n2 = E("DialogOverlay", e3.__scopeDialog);
  return n2.modal ? m.createElement(Presence, { present: t5 || n2.open }, m.createElement(R, _extends({}, r4, { ref: o4 }))) : null;
});
var R = m.forwardRef((o4, r4) => {
  const { __scopeDialog: a2, ...i3 } = o4, l = E("DialogOverlay", a2);
  return m.createElement(Combination_default, { as: Slot, allowPinchZoom: l.allowPinchZoom, shards: [l.contentRef] }, m.createElement(Primitive.div, _extends({ "data-state": b(l.open) }, i3, { ref: r4, style: { pointerEvents: "auto", ...i3.style } })));
});
var DialogContent = m.forwardRef((e3, o4) => {
  const { forceMount: t5, ...r4 } = e3, n2 = E("DialogContent", e3.__scopeDialog);
  return m.createElement(Presence, { present: t5 || n2.open }, n2.modal ? m.createElement(_, _extends({}, r4, { ref: o4 })) : m.createElement(O, _extends({}, r4, { ref: o4 })));
});
var _ = m.forwardRef((e3, t5) => {
  const r4 = E("DialogContent", e3.__scopeDialog), n2 = m.useRef(null), a2 = useComposedRefs(t5, r4.contentRef, n2);
  return m.useEffect(() => {
    const e4 = n2.current;
    if (e4)
      return hideOthers(e4);
  }, []), m.createElement(h, _extends({}, e3, { ref: a2, trapFocus: r4.open, disableOutsidePointerEvents: true, onCloseAutoFocus: composeEventHandlers(e3.onCloseAutoFocus, (e4) => {
    var o4;
    e4.preventDefault(), null === (o4 = r4.triggerRef.current) || void 0 === o4 || o4.focus();
  }), onPointerDownOutside: composeEventHandlers(e3.onPointerDownOutside, (e4) => {
    const o4 = e4.detail.originalEvent, t6 = 0 === o4.button && true === o4.ctrlKey;
    (2 === o4.button || t6) && e4.preventDefault();
  }), onFocusOutside: composeEventHandlers(e3.onFocusOutside, (e4) => e4.preventDefault()) }));
});
var O = m.forwardRef((e3, o4) => {
  const t5 = E("DialogContent", e3.__scopeDialog), r4 = m.useRef(false);
  return m.createElement(h, _extends({}, e3, { ref: o4, trapFocus: false, disableOutsidePointerEvents: false, onCloseAutoFocus: (o5) => {
    var n2, a2;
    (null === (n2 = e3.onCloseAutoFocus) || void 0 === n2 || n2.call(e3, o5), o5.defaultPrevented) || (r4.current || null === (a2 = t5.triggerRef.current) || void 0 === a2 || a2.focus(), o5.preventDefault());
    r4.current = false;
  }, onInteractOutside: (o5) => {
    var n2, a2;
    null === (n2 = e3.onInteractOutside) || void 0 === n2 || n2.call(e3, o5), o5.defaultPrevented || (r4.current = true);
    const i3 = o5.target;
    (null === (a2 = t5.triggerRef.current) || void 0 === a2 ? void 0 : a2.contains(i3)) && o5.preventDefault();
  } }));
});
var h = m.forwardRef((e3, o4) => {
  const { __scopeDialog: t5, trapFocus: n2, onOpenAutoFocus: a2, onCloseAutoFocus: i3, ...s2 } = e3, u2 = E("DialogContent", t5), p = m.useRef(null), d3 = useComposedRefs(o4, p);
  return useFocusGuards(), m.createElement(m.Fragment, null, m.createElement(FocusScope, { asChild: true, loop: true, trapped: n2, onMountAutoFocus: a2, onUnmountAutoFocus: i3 }, m.createElement(DismissableLayer, _extends({ role: "dialog", id: u2.contentId, "aria-describedby": u2.descriptionId, "aria-labelledby": u2.titleId, "data-state": b(u2.open) }, s2, { ref: d3, onDismiss: () => u2.onOpenChange(false) }))), false);
});
var DialogTitle = m.forwardRef((e3, o4) => {
  const { __scopeDialog: t5, ...r4 } = e3, a2 = E("DialogTitle", t5);
  return m.createElement(Primitive.h2, _extends({ id: a2.titleId }, r4, { ref: o4 }));
});
var DialogDescription = m.forwardRef((e3, o4) => {
  const { __scopeDialog: t5, ...r4 } = e3, a2 = E("DialogDescription", t5);
  return m.createElement(Primitive.p, _extends({ id: a2.descriptionId }, r4, { ref: o4 }));
});
var DialogClose = m.forwardRef((e3, o4) => {
  const { __scopeDialog: t5, ...r4 } = e3, a2 = E("DialogClose", t5);
  return m.createElement(Primitive.button, _extends({ type: "button" }, r4, { ref: o4, onClick: composeEventHandlers(e3.onClick, () => a2.onOpenChange(false)) }));
});
function b(e3) {
  return e3 ? "open" : "closed";
}
var [w, F] = createContext("DialogTitleWarning", { contentName: "DialogContent", titleName: "DialogTitle", docsSlug: "dialog" });
var Root = Dialog;
var Trigger = DialogTrigger;
var Portal2 = DialogPortal;
var Overlay = DialogOverlay;
var Content = DialogContent;
var Title = DialogTitle;
var Description = DialogDescription;
var Close = DialogClose;
export {
  Close,
  Content,
  Description,
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
  Overlay,
  Portal2 as Portal,
  Root,
  Title,
  Trigger,
  w as WarningProvider,
  C as createDialogScope
};
//# sourceMappingURL=@radix-ui_react-dialog.js.map
