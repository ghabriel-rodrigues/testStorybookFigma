{
  "version": 3,
  "sources": ["dep:@react-stately_combobox", "../../../../../node_modules/@react-stately/selection/dist/packages/@react-stately/selection/src/index.ts", "../../../../../node_modules/@react-stately/selection/dist/packages/@react-stately/selection/src/useMultipleSelectionState.ts", "../../../../../node_modules/@react-stately/selection/dist/packages/@react-stately/selection/src/Selection.ts", "../../../../../node_modules/@react-stately/selection/dist/packages/@react-stately/selection/src/SelectionManager.ts", "../../../../../node_modules/@react-stately/selection/dist/packages/@react-stately/selection/src/types.ts", "../../../../../node_modules/@react-stately/list/dist/packages/@react-stately/list/src/index.ts", "../../../../../node_modules/@react-stately/list/dist/packages/@react-stately/list/src/useListState.ts", "../../../../../node_modules/@react-stately/list/dist/packages/@react-stately/list/src/ListCollection.ts", "../../../../../node_modules/@react-stately/list/dist/packages/@react-stately/list/src/useSingleSelectListState.ts", "../../../../../node_modules/@react-stately/menu/dist/packages/@react-stately/menu/src/index.ts", "../../../../../node_modules/@react-stately/menu/dist/packages/@react-stately/menu/src/useMenuTriggerState.ts", "../../../../../node_modules/@react-stately/combobox/dist/packages/@react-stately/combobox/src/index.ts", "../../../../../node_modules/@react-stately/combobox/dist/packages/@react-stately/combobox/src/useComboBoxState.ts"],
  "sourcesContent": ["\nexport * from \"../../node_modules/@react-stately/combobox/dist/module.js\"", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport * from './useMultipleSelectionState';\nexport * from './SelectionManager';\nexport * from './types';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DisabledBehavior, MultipleSelection, SelectionBehavior, SelectionMode} from '@react-types/shared';\nimport {Key, useEffect, useMemo, useRef, useState} from 'react';\nimport {MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\nimport {useControlledState} from '@react-stately/utils';\n\nfunction equalSets(setA, setB) {\n  if (setA.size !== setB.size) {\n    return false;\n  }\n\n  for (let item of setA) {\n    if (!setB.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport interface MultipleSelectionStateProps extends MultipleSelection {\n  /** How multiple selection should behave in the collection. */\n  selectionBehavior?: SelectionBehavior,\n  /** Whether onSelectionChange should fire even if the new set of keys is the same as the last. */\n  allowDuplicateSelectionEvents?: boolean,\n  /** Whether `disabledKeys` applies to all interactions, or only selection. */\n  disabledBehavior?: DisabledBehavior\n}\n\n/**\n * Manages state for multiple selection and focus in a collection.\n */\nexport function useMultipleSelectionState(props: MultipleSelectionStateProps): MultipleSelectionState {\n  let {\n    selectionMode = 'none' as SelectionMode,\n    disallowEmptySelection,\n    allowDuplicateSelectionEvents,\n    selectionBehavior: selectionBehaviorProp = 'toggle',\n    disabledBehavior = 'all'\n  } = props;\n\n  // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n  // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n  let isFocusedRef = useRef(false);\n  let [, setFocused] = useState(false);\n  let focusedKeyRef = useRef(null);\n  let childFocusStrategyRef = useRef(null);\n  let [, setFocusedKey] = useState(null);\n  let selectedKeysProp = useMemo(() => convertSelection(props.selectedKeys), [props.selectedKeys]);\n  let defaultSelectedKeys = useMemo(() => convertSelection(props.defaultSelectedKeys, new Selection()), [props.defaultSelectedKeys]);\n  let [selectedKeys, setSelectedKeys] = useControlledState(\n    selectedKeysProp,\n    defaultSelectedKeys,\n    props.onSelectionChange\n  );\n  let disabledKeysProp = useMemo(() =>\n    props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n  , [props.disabledKeys]);\n  let [selectionBehavior, setSelectionBehavior] = useState(selectionBehaviorProp);\n\n  // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n  // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n  if (selectionBehaviorProp === 'replace' && selectionBehavior === 'toggle' && typeof selectedKeys === 'object' && selectedKeys.size === 0) {\n    setSelectionBehavior('replace');\n  }\n\n  // If the selectionBehavior prop changes, update the state as well.\n  let lastSelectionBehavior = useRef(selectionBehaviorProp);\n  useEffect(() => {\n    if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n      setSelectionBehavior(selectionBehaviorProp);\n      lastSelectionBehavior.current = selectionBehaviorProp;\n    }\n  }, [selectionBehaviorProp]);\n\n  return {\n    selectionMode,\n    disallowEmptySelection,\n    selectionBehavior,\n    setSelectionBehavior,\n    get isFocused() {\n      return isFocusedRef.current;\n    },\n    setFocused(f) {\n      isFocusedRef.current = f;\n      setFocused(f);\n    },\n    get focusedKey() {\n      return focusedKeyRef.current;\n    },\n    get childFocusStrategy() {\n      return childFocusStrategyRef.current;\n    },\n    setFocusedKey(k, childFocusStrategy = 'first') {\n      focusedKeyRef.current = k;\n      childFocusStrategyRef.current = childFocusStrategy;\n      setFocusedKey(k);\n    },\n    selectedKeys,\n    setSelectedKeys(keys) {\n      if (allowDuplicateSelectionEvents || !equalSets(keys, selectedKeys)) {\n        setSelectedKeys(keys);\n      }\n    },\n    disabledKeys: disabledKeysProp,\n    disabledBehavior\n  };\n}\n\nfunction convertSelection(selection: 'all' | Iterable<Key>, defaultValue?: Selection): 'all' | Selection {\n  if (!selection) {\n    return defaultValue;\n  }\n\n  return selection === 'all'\n    ? 'all'\n    : new Selection(selection);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\n\n/**\n * A Selection is a special Set containing Keys, which also has an anchor\n * and current selected key for use when range selecting.\n */\nexport class Selection extends Set<Key> {\n  anchorKey: Key;\n  currentKey: Key;\n\n  constructor(keys?: Iterable<Key> | Selection, anchorKey?: Key, currentKey?: Key) {\n    super(keys);\n    if (keys instanceof Selection) {\n      this.anchorKey = anchorKey || keys.anchorKey;\n      this.currentKey = currentKey || keys.currentKey;\n    } else {\n      this.anchorKey = anchorKey;\n      this.currentKey = currentKey;\n    }\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  Collection,\n  DisabledBehavior,\n  FocusStrategy,\n  Selection as ISelection,\n  LongPressEvent,\n  Node,\n  PressEvent,\n  SelectionBehavior,\n  SelectionMode\n} from '@react-types/shared';\nimport {Key} from 'react';\nimport {MultipleSelectionManager, MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\n\ninterface SelectionManagerOptions {\n  allowsCellSelection?: boolean\n}\n\n/**\n * An interface for reading and updating multiple selection state.\n */\nexport class SelectionManager implements MultipleSelectionManager {\n  private collection: Collection<Node<unknown>>;\n  private state: MultipleSelectionState;\n  private allowsCellSelection: boolean;\n  private _isSelectAll: boolean;\n\n  constructor(collection: Collection<Node<unknown>>, state: MultipleSelectionState, options?: SelectionManagerOptions) {\n    this.collection = collection;\n    this.state = state;\n    this.allowsCellSelection = options?.allowsCellSelection ?? false;\n    this._isSelectAll = null;\n  }\n\n  /**\n   * The type of selection that is allowed in the collection.\n   */\n  get selectionMode(): SelectionMode {\n    return this.state.selectionMode;\n  }\n\n  /**\n   * Whether the collection allows empty selection.\n   */\n  get disallowEmptySelection(): boolean {\n    return this.state.disallowEmptySelection;\n  }\n\n  /**\n   * The selection behavior for the collection.\n   */\n  get selectionBehavior(): SelectionBehavior {\n    return this.state.selectionBehavior;\n  }\n\n  /**\n   * Sets the selection behavior for the collection.\n   */\n  setSelectionBehavior(selectionBehavior: SelectionBehavior) {\n    this.state.setSelectionBehavior(selectionBehavior);\n  }\n\n  /**\n   * Whether the collection is currently focused.\n   */\n  get isFocused(): boolean {\n    return this.state.isFocused;\n  }\n\n  /**\n   * Sets whether the collection is focused.\n   */\n  setFocused(isFocused: boolean) {\n    this.state.setFocused(isFocused);\n  }\n\n  /**\n   * The current focused key in the collection.\n   */\n  get focusedKey(): Key {\n    return this.state.focusedKey;\n  }\n\n  /** Whether the first or last child of the focused key should receive focus. */\n  get childFocusStrategy(): FocusStrategy {\n    return this.state.childFocusStrategy;\n  }\n\n  /**\n   * Sets the focused key.\n   */\n  setFocusedKey(key: Key, childFocusStrategy?: FocusStrategy) {\n    this.state.setFocusedKey(key, childFocusStrategy);\n  }\n\n  /**\n   * The currently selected keys in the collection.\n   */\n  get selectedKeys(): Set<Key> {\n    return this.state.selectedKeys === 'all'\n      ? new Set(this.getSelectAllKeys())\n      : this.state.selectedKeys;\n  }\n\n  /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */\n  get rawSelection(): ISelection {\n    return this.state.selectedKeys;\n  }\n\n  /**\n   * Returns whether a key is selected.\n   */\n  isSelected(key: Key) {\n    if (this.state.selectionMode === 'none') {\n      return false;\n    }\n\n    key = this.getKey(key);\n    return this.state.selectedKeys === 'all'\n      ? this.canSelectItem(key)\n      : this.state.selectedKeys.has(key);\n  }\n\n  /**\n   * Whether the selection is empty.\n   */\n  get isEmpty(): boolean {\n    return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;\n  }\n\n  /**\n   * Whether all items in the collection are selected.\n   */\n  get isSelectAll(): boolean {\n    if (this.isEmpty) {\n      return false;\n    }\n\n    if (this.state.selectedKeys === 'all') {\n      return true;\n    }\n\n    if (this._isSelectAll != null) {\n      return this._isSelectAll;\n    }\n\n    let allKeys = this.getSelectAllKeys();\n    let selectedKeys = this.state.selectedKeys;\n    this._isSelectAll = allKeys.every(k => selectedKeys.has(k));\n    return this._isSelectAll;\n  }\n\n  get firstSelectedKey(): Key | null {\n    let first: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!first || item?.index < first.index) {\n        first = item;\n      }\n    }\n\n    return first?.key;\n  }\n\n  get lastSelectedKey(): Key | null {\n    let last: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!last || item?.index > last.index) {\n        last = item;\n      }\n    }\n\n    return last?.key;\n  }\n\n  get disabledKeys(): Set<Key> {\n    return this.state.disabledKeys;\n  }\n\n  get disabledBehavior(): DisabledBehavior {\n    return this.state.disabledBehavior;\n  }\n\n  /**\n   * Extends the selection to the given key.\n   */\n  extendSelection(toKey: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      this.replaceSelection(toKey);\n      return;\n    }\n\n    toKey = this.getKey(toKey);\n\n    let selection: Selection;\n\n    // Only select the one key if coming from a select all.\n    if (this.state.selectedKeys === 'all') {\n      selection = new Selection([toKey], toKey, toKey);\n    } else {\n      let selectedKeys = this.state.selectedKeys as Selection;\n      let anchorKey = selectedKeys.anchorKey || toKey;\n      selection = new Selection(selectedKeys, anchorKey, toKey);\n      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) {\n        selection.delete(key);\n      }\n\n      for (let key of this.getKeyRange(toKey, anchorKey)) {\n        if (this.canSelectItem(key)) {\n          selection.add(key);\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getKeyRange(from: Key, to: Key) {\n    let fromItem = this.collection.getItem(from);\n    let toItem = this.collection.getItem(to);\n    if (fromItem && toItem) {\n      if (fromItem.index <= toItem.index) {\n        return this.getKeyRangeInternal(from, to);\n      }\n\n      return this.getKeyRangeInternal(to, from);\n    }\n\n    return [];\n  }\n\n  private getKeyRangeInternal(from: Key, to: Key) {\n    let keys: Key[] = [];\n    let key = from;\n    while (key) {\n      let item = this.collection.getItem(key);\n      if (item && item.type === 'item' || (item.type === 'cell' && this.allowsCellSelection)) {\n        keys.push(key);\n      }\n\n      if (key === to) {\n        return keys;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return [];\n  }\n\n  private getKey(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      // \u00AF\\_(\u30C4)_/\u00AF\n      return key;\n    }\n\n    // If cell selection is allowed, just return the key.\n    if (item.type === 'cell' && this.allowsCellSelection) {\n      return key;\n    }\n\n    // Find a parent item to select\n    while (item.type !== 'item' && item.parentKey != null) {\n      item = this.collection.getItem(item.parentKey);\n    }\n\n    if (!item || item.type !== 'item') {\n      return null;\n    }\n\n    return item.key;\n  }\n\n  /**\n   * Toggles whether the given key is selected.\n   */\n  toggleSelection(key: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single' && !this.isSelected(key)) {\n      this.replaceSelection(key);\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    let keys = new Selection(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);\n    if (keys.has(key)) {\n      keys.delete(key);\n      // TODO: move anchor to last selected key...\n      // Does `current` need to move here too?\n    } else if (this.canSelectItem(key)) {\n      keys.add(key);\n      keys.anchorKey = key;\n      keys.currentKey = key;\n    }\n\n    if (this.disallowEmptySelection && keys.size === 0) {\n      return;\n    }\n\n    this.state.setSelectedKeys(keys);\n  }\n\n  /**\n   * Replaces the selection with only the given key.\n   */\n  replaceSelection(key: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    let selection = this.canSelectItem(key)\n      ? new Selection([key], key, key)\n      : new Selection();\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  /**\n   * Replaces the selection with the given keys.\n   */\n  setSelectedKeys(keys: Iterable<Key>) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    let selection = new Selection();\n    for (let key of keys) {\n      key = this.getKey(key);\n      if (key != null) {\n        selection.add(key);\n        if (this.selectionMode === 'single') {\n          break;\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getSelectAllKeys() {\n    let keys: Key[] = [];\n    let addKeys = (key: Key) => {\n      while (key) {\n        if (this.canSelectItem(key)) {\n          let item = this.collection.getItem(key);\n          if (item.type === 'item') {\n            keys.push(key);\n          }\n\n          // Add child keys. If cell selection is allowed, then include item children too.\n          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== 'item')) {\n            addKeys([...item.childNodes][0].key);\n          }\n        }\n\n        key = this.collection.getKeyAfter(key);\n      }\n    };\n\n    addKeys(this.collection.getFirstKey());\n    return keys;\n  }\n\n  /**\n   * Selects all items in the collection.\n   */\n  selectAll() {\n    if (this.selectionMode === 'multiple') {\n      this.state.setSelectedKeys('all');\n    }\n  }\n\n  /**\n   * Removes all keys from the selection.\n   */\n  clearSelection() {\n    if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) {\n      this.state.setSelectedKeys(new Selection());\n    }\n  }\n\n  /**\n   * Toggles between select all and an empty selection.\n   */\n  toggleSelectAll() {\n    if (this.isSelectAll) {\n      this.clearSelection();\n    } else {\n      this.selectAll();\n    }\n  }\n\n  select(key: Key, e?: PressEvent | LongPressEvent | PointerEvent) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      if (this.isSelected(key) && !this.disallowEmptySelection) {\n        this.toggleSelection(key);\n      } else {\n        this.replaceSelection(key);\n      }\n    } else if (this.selectionBehavior === 'toggle' || (e && (e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n      // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n      this.toggleSelection(key);\n    } else {\n      this.replaceSelection(key);\n    }\n  }\n\n  /**\n   * Returns whether the current selection is equal to the given selection.\n   */\n  isSelectionEqual(selection: Set<Key>) {\n    if (selection === this.state.selectedKeys) {\n      return true;\n    }\n\n    // Check if the set of keys match.\n    let selectedKeys = this.selectedKeys;\n    if (selection.size !== selectedKeys.size) {\n      return false;\n    }\n\n    for (let key of selection) {\n      if (!selectedKeys.has(key)) {\n        return false;\n      }\n    }\n\n    for (let key of selectedKeys) {\n      if (!selection.has(key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  canSelectItem(key: Key) {\n    if (this.state.selectionMode === 'none' || this.state.disabledKeys.has(key)) {\n      return false;\n    }\n\n    let item = this.collection.getItem(key);\n    if (!item || (item.type === 'cell' && !this.allowsCellSelection)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  isDisabled(key: Key) {\n    return this.state.disabledKeys.has(key) && this.state.disabledBehavior === 'all';\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DisabledBehavior, FocusStrategy, LongPressEvent, PressEvent, Selection, SelectionBehavior, SelectionMode} from '@react-types/shared';\nimport {Key} from 'react';\n\nexport interface FocusState {\n  /** Whether the collection is currently focused. */\n  readonly isFocused: boolean,\n  /** Sets whether the collection is focused. */\n  setFocused(isFocused: boolean): void,\n  /** The current focused key in the collection. */\n  readonly focusedKey: Key,\n  /** Whether the first or last child of the focused key should receive focus. */\n  readonly childFocusStrategy: FocusStrategy,\n  /** Sets the focused key, and optionally, whether the first or last child of that key should receive focus. */\n  setFocusedKey(key: Key, child?: FocusStrategy): void\n}\n\nexport interface SingleSelectionState extends FocusState {\n  /** Whether the collection allows empty selection. */\n  readonly disallowEmptySelection?: boolean,\n  /** The currently selected key in the collection. */\n  readonly selectedKey: Key,\n  /** Sets the selected key in the collection. */\n  setSelectedKey(key: Key): void\n}\n\nexport interface MultipleSelectionState extends FocusState {\n  /** The type of selection that is allowed in the collection. */\n  readonly selectionMode: SelectionMode,\n  /** The selection behavior for the collection. */\n  readonly selectionBehavior: SelectionBehavior,\n  /** Sets the selection behavior for the collection. */\n  setSelectionBehavior(selectionBehavior: SelectionBehavior): void,\n  /** Whether the collection allows empty selection. */\n  readonly disallowEmptySelection: boolean,\n  /** The currently selected keys in the collection. */\n  readonly selectedKeys: Selection,\n  /** Sets the selected keys in the collection. */\n  setSelectedKeys(keys: Selection): void,\n  /** The currently disabled keys in the collection. */\n  readonly disabledKeys: Set<Key>,\n  /** Whether `disabledKeys` applies to selection, actions, or both. */\n  readonly disabledBehavior: DisabledBehavior\n}\n\nexport interface MultipleSelectionManager extends FocusState {\n  /** The type of selection that is allowed in the collection. */\n  readonly selectionMode: SelectionMode,\n  /** The selection behavior for the collection. */\n  readonly selectionBehavior: SelectionBehavior,\n  /** Whether the collection allows empty selection. */\n  readonly disallowEmptySelection?: boolean,\n  /** The currently selected keys in the collection. */\n  readonly selectedKeys: Set<Key>,\n  /** Whether the selection is empty. */\n  readonly isEmpty: boolean,\n  /** Whether all items in the collection are selected. */\n  readonly isSelectAll: boolean,\n  /** The first selected key in the collection. */\n  readonly firstSelectedKey: Key | null,\n  /** The last selected key in the collection. */\n  readonly lastSelectedKey: Key | null,\n  /** The currently disabled keys in the collection. */\n  readonly disabledKeys: Set<Key>,\n  /** Whether `disabledKeys` applies to selection, actions, or both. */\n  readonly disabledBehavior: DisabledBehavior,\n  /** Returns whether a key is selected. */\n  isSelected(key: Key): boolean,\n  /** Returns whether the current selection is equal to the given selection. */\n  isSelectionEqual(selection: Set<Key>): boolean,\n  /** Extends the selection to the given key. */\n  extendSelection(toKey: Key): void,\n  /** Toggles whether the given key is selected. */\n  toggleSelection(key: Key): void,\n  /** Replaces the selection with only the given key. */\n  replaceSelection(key: Key): void,\n  /** Replaces the selection with the given keys. */\n  setSelectedKeys(keys: Iterable<Key>): void,\n  /** Selects all items in the collection. */\n  selectAll(): void,\n  /** Removes all keys from the selection. */\n  clearSelection(): void,\n  /** Toggles between select all and an empty selection. */\n  toggleSelectAll(): void,\n  /**\n   * Toggles, replaces, or extends selection to the given key depending\n   * on the pointer event and collection's selection mode.\n   */\n  select(key: Key, e?: PressEvent | LongPressEvent | PointerEvent): void,\n  /** Returns whether the given key can be selected. */\n  canSelectItem(key: Key): boolean,\n  /** Returns whether the given key is non-interactive, i.e. both selection and actions are disabled. */\n  isDisabled(key: Key): boolean,\n  /** Sets the selection behavior for the collection. */\n  setSelectionBehavior(selectionBehavior: SelectionBehavior): void\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport * from './useListState';\nexport * from './useSingleSelectListState';\nexport * from './ListCollection';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, CollectionBase, Node} from '@react-types/shared';\nimport {Key, useEffect, useMemo} from 'react';\nimport {ListCollection} from './ListCollection';\nimport {MultipleSelectionStateProps, SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\nimport {useCollection} from '@react-stately/collections';\n\nexport interface ListProps<T> extends CollectionBase<T>, MultipleSelectionStateProps {\n  /** Filter function to generate a filtered list of nodes. */\n  filter?: (nodes: Iterable<Node<T>>) => Iterable<Node<T>>,\n  /** @private */\n  suppressTextValueWarning?: boolean\n}\n\nexport interface ListState<T> {\n  /** A collection of items in the list. */\n  collection: Collection<Node<T>>,\n\n  /** A set of items that are disabled. */\n  disabledKeys: Set<Key>,\n\n  /** A selection manager to read and update multiple selection state. */\n  selectionManager: SelectionManager\n}\n\n/**\n * Provides state management for list-like components. Handles building a collection\n * of items from props, and manages multiple selection state.\n */\nexport function useListState<T extends object>(props: ListProps<T>): ListState<T>  {\n  let {filter} = props;\n\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n    props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n  , [props.disabledKeys]);\n\n  let factory = nodes => filter ? new ListCollection(filter(nodes)) : new ListCollection(nodes as Iterable<Node<T>>);\n  let context = useMemo(() => ({suppressTextValueWarning: props.suppressTextValueWarning}), [props.suppressTextValueWarning]);\n\n  let collection = useCollection(props, factory, context, [filter]);\n\n  // Reset focused key if that item is deleted from the collection.\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      selectionState.setFocusedKey(null);\n    }\n  }, [collection, selectionState.focusedKey]);\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager: new SelectionManager(collection, selectionState)\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, Node} from '@react-types/shared';\nimport {Key} from 'react';\n\nexport class ListCollection<T> implements Collection<Node<T>> {\n  private keyMap: Map<Key, Node<T>> = new Map();\n  private iterable: Iterable<Node<T>>;\n  private firstKey: Key;\n  private lastKey: Key;\n\n  constructor(nodes: Iterable<Node<T>>) {\n    this.iterable = nodes;\n\n    let visit = (node: Node<T>) => {\n      this.keyMap.set(node.key, node);\n\n      if (node.childNodes && node.type === 'section') {\n        for (let child of node.childNodes) {\n          visit(child);\n        }\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let last: Node<T>;\n    let index = 0;\n    for (let [key, node] of this.keyMap) {\n      if (last) {\n        last.nextKey = key;\n        node.prevKey = last.key;\n      } else {\n        this.firstKey = key;\n        node.prevKey = undefined;\n      }\n\n      if (node.type === 'item') {\n        node.index = index++;\n      }\n\n      last = node;\n\n      // Set nextKey as undefined since this might be the last node\n      // If it isn't the last node, last.nextKey will properly set at start of new loop\n      last.nextKey = undefined;\n    }\n\n    this.lastKey = last?.key;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.iterable;\n  }\n\n  get size() {\n    return this.keyMap.size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return this.firstKey;\n  }\n\n  getLastKey() {\n    return this.lastKey;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBase, SingleSelection} from '@react-types/shared';\nimport {Key, useMemo} from 'react';\nimport {ListState, useListState} from './useListState';\nimport {Node} from '@react-types/shared';\nimport {useControlledState} from '@react-stately/utils';\n\nexport interface SingleSelectListProps<T> extends CollectionBase<T>, Omit<SingleSelection, 'disallowEmptySelection'> {\n  /** Filter function to generate a filtered list of nodes. */\n  filter?: (nodes: Iterable<Node<T>>) => Iterable<Node<T>>,\n  /** @private */\n  suppressTextValueWarning?: boolean\n}\n\nexport interface SingleSelectListState<T> extends ListState<T> {\n  /** The key for the currently selected item. */\n  readonly selectedKey: Key,\n\n  /** Sets the selected key. */\n  setSelectedKey(key: Key): void,\n\n  /** The value of the currently selected item. */\n  readonly selectedItem: Node<T>\n}\n\n/**\n * Provides state management for list-like components with single selection.\n * Handles building a collection of items from props, and manages selection state.\n */\nexport function useSingleSelectListState<T extends object>(props: SingleSelectListProps<T>): SingleSelectListState<T>  {\n  let [selectedKey, setSelectedKey] = useControlledState(props.selectedKey, props.defaultSelectedKey ?? null, props.onSelectionChange);\n  let selectedKeys = useMemo(() => selectedKey != null ? [selectedKey] : [], [selectedKey]);\n  let {collection, disabledKeys, selectionManager} = useListState({\n    ...props,\n    selectionMode: 'single',\n    disallowEmptySelection: true,\n    allowDuplicateSelectionEvents: true,\n    selectedKeys,\n    onSelectionChange: (keys: Set<Key>) => {\n      let key = keys.values().next().value;\n\n      // Always fire onSelectionChange, even if the key is the same\n      // as the current key (useControlledState does not).\n      if (key === selectedKey && props.onSelectionChange) {\n        props.onSelectionChange(key);\n      }\n\n      setSelectedKey(key);\n    }\n  });\n\n  let selectedItem = selectedKey != null\n    ? collection.getItem(selectedKey)\n    : null;\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager,\n    selectedKey,\n    setSelectedKey,\n    selectedItem\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport * from './useMenuTriggerState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusStrategy} from '@react-types/shared';\nimport {MenuTriggerProps} from '@react-types/menu';\nimport {OverlayTriggerState, useOverlayTriggerState} from '@react-stately/overlays';\nimport {useState} from 'react';\n\nexport interface MenuTriggerState extends OverlayTriggerState {\n  /** Controls which item will be auto focused when the menu opens. */\n  readonly focusStrategy: FocusStrategy,\n\n  /** Opens the menu. */\n  open(focusStrategy?: FocusStrategy | null): void,\n\n  /** Toggles the menu. */\n  toggle(focusStrategy?: FocusStrategy | null): void\n}\n\n/**\n * Manages state for a menu trigger. Tracks whether the menu is currently open,\n * and controls which item will receive focus when it opens.\n */\nexport function useMenuTriggerState(props: MenuTriggerProps): MenuTriggerState  {\n  let overlayTriggerState = useOverlayTriggerState(props);\n  let [focusStrategy, setFocusStrategy] = useState<FocusStrategy>(null);\n\n  return {\n    focusStrategy,\n    ...overlayTriggerState,\n    open(focusStrategy: FocusStrategy = null) {\n      setFocusStrategy(focusStrategy);\n      overlayTriggerState.open();\n    },\n    toggle(focusStrategy: FocusStrategy = null) {\n      setFocusStrategy(focusStrategy);\n      overlayTriggerState.toggle();\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport * from './useComboBoxState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, FocusStrategy, Node} from '@react-types/shared';\nimport {ComboBoxProps, MenuTriggerAction} from '@react-types/combobox';\nimport {ListCollection, useSingleSelectListState} from '@react-stately/list';\nimport {SelectState} from '@react-stately/select';\nimport {useControlledState} from '@react-stately/utils';\nimport {useEffect, useMemo, useRef, useState} from 'react';\nimport {useMenuTriggerState} from '@react-stately/menu';\n\nexport interface ComboBoxState<T> extends SelectState<T> {\n  /** The current value of the combo box input. */\n  inputValue: string,\n  /** Sets the value of the combo box input. */\n  setInputValue(value: string): void,\n  /** Selects the currently focused item and updates the input value. */\n  commit(): void,\n  /** Opens the menu. */\n  open(focusStrategy?: FocusStrategy | null, trigger?: MenuTriggerAction): void,\n  /** Toggles the menu. */\n  toggle(focusStrategy?: FocusStrategy | null, trigger?: MenuTriggerAction): void,\n  /** Resets the input value to the previously selected item's text if any and closes the menu.  */\n  revert(): void\n}\n\ntype FilterFn = (textValue: string, inputValue: string) => boolean;\ninterface ComboBoxStateProps<T> extends ComboBoxProps<T> {\n  /** The filter function used to determine if a option should be included in the combo box list. */\n  defaultFilter?: FilterFn,\n  /** Whether the combo box allows the menu to be open when the collection is empty. */\n  allowsEmptyCollection?: boolean,\n  /** Whether the combo box menu should close on blur. */\n  shouldCloseOnBlur?: boolean\n}\n\n/**\n * Provides state management for a combo box component. Handles building a collection\n * of items from props and manages the option selection state of the combo box. In addition, it tracks the input value,\n * focus state, and other properties of the combo box.\n */\nexport function useComboBoxState<T extends object>(props: ComboBoxStateProps<T>): ComboBoxState<T> {\n  let {\n    defaultFilter,\n    menuTrigger = 'input',\n    allowsEmptyCollection = false,\n    allowsCustomValue,\n    shouldCloseOnBlur = true\n  } = props;\n\n  let [showAllItems, setShowAllItems] = useState(false);\n  let [isFocused, setFocusedState] = useState(false);\n  let [inputValue, setInputValue] = useControlledState(\n    props.inputValue,\n    props.defaultInputValue ?? '',\n    props.onInputChange\n  );\n\n  let onSelectionChange = (key) => {\n    if (props.onSelectionChange) {\n      props.onSelectionChange(key);\n    }\n\n    // If key is the same, reset the inputValue and close the menu\n    // (scenario: user clicks on already selected option)\n    if (key === selectedKey) {\n      resetInputValue();\n      triggerState.close();\n    }\n  };\n\n  let {collection, selectionManager, selectedKey, setSelectedKey, selectedItem, disabledKeys} = useSingleSelectListState({\n    ...props,\n    onSelectionChange,\n    items: props.items ?? props.defaultItems\n  });\n\n  // Preserve original collection so we can show all items on demand\n  let originalCollection = collection;\n  let filteredCollection = useMemo(() => (\n    // No default filter if items are controlled.\n    props.items != null || !defaultFilter\n      ? collection\n      : filterCollection(collection, inputValue, defaultFilter)\n  ), [collection, inputValue, defaultFilter, props.items]);\n\n  // Track what action is attempting to open the menu\n  let menuOpenTrigger = useRef('focus' as MenuTriggerAction);\n  let onOpenChange = (open: boolean) => {\n    if (props.onOpenChange) {\n      props.onOpenChange(open, open ? menuOpenTrigger.current : undefined);\n    }\n  };\n\n  let triggerState = useMenuTriggerState({...props, onOpenChange, isOpen: undefined, defaultOpen: undefined});\n  let open = (focusStrategy?: FocusStrategy, trigger?: MenuTriggerAction) => {\n    let displayAllItems = (trigger === 'manual' || (trigger === 'focus' && menuTrigger === 'focus'));\n    // Prevent open operations from triggering if there is nothing to display\n    // Also prevent open operations from triggering if items are uncontrolled but defaultItems is empty, even if displayAllItems is true.\n    // This is to prevent comboboxes with empty defaultItems from opening but allow controlled items comboboxes to open even if the inital list is empty (assumption is user will provide swap the empty list with a base list via onOpenChange returning `menuTrigger` manual)\n    if (allowsEmptyCollection || filteredCollection.size > 0 || (displayAllItems && originalCollection.size > 0) || props.items) {\n      if (displayAllItems && !triggerState.isOpen && props.items === undefined) {\n        // Show all items if menu is manually opened. Only care about this if items are undefined\n        setShowAllItems(true);\n      }\n\n      menuOpenTrigger.current = trigger;\n      triggerState.open(focusStrategy);\n    }\n  };\n\n  let toggle = (focusStrategy?: FocusStrategy, trigger?: MenuTriggerAction) => {\n    let displayAllItems = (trigger === 'manual' || (trigger === 'focus' && menuTrigger === 'focus'));\n    // If the menu is closed and there is nothing to display, early return so toggle isn't called to prevent extraneous onOpenChange\n    if (!(allowsEmptyCollection || filteredCollection.size > 0 || (displayAllItems && originalCollection.size > 0) || props.items) && !triggerState.isOpen) {\n      return;\n    }\n\n    if (displayAllItems && !triggerState.isOpen && props.items === undefined) {\n      // Show all items if menu is toggled open. Only care about this if items are undefined\n      setShowAllItems(true);\n    }\n\n    // Only update the menuOpenTrigger if menu is currently closed\n    if (!triggerState.isOpen) {\n      menuOpenTrigger.current = trigger;\n    }\n\n    triggerState.toggle(focusStrategy);\n  };\n\n  let lastValue = useRef(inputValue);\n  let resetInputValue = () => {\n    let itemText = collection.getItem(selectedKey)?.textValue ?? '';\n    lastValue.current = itemText;\n    setInputValue(itemText);\n  };\n\n  let isInitialRender = useRef(true);\n  let lastSelectedKey = useRef(props.selectedKey ?? props.defaultSelectedKey ?? null);\n  let lastSelectedKeyText = useRef(collection.getItem(selectedKey)?.textValue ?? '');\n  // intentional omit dependency array, want this to happen on every render\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(() => {\n    // Open and close menu automatically when the input value changes if the input is focused,\n    // and there are items in the collection or allowEmptyCollection is true.\n    if (\n      isFocused &&\n      (filteredCollection.size > 0 || allowsEmptyCollection) &&\n      !triggerState.isOpen &&\n      inputValue !== lastValue.current &&\n      menuTrigger !== 'manual'\n    ) {\n      open(null, 'input');\n    }\n\n    // Close the menu if the collection is empty. Don't close menu if filtered collection size is 0\n    // but we are currently showing all items via button press\n    if (\n      !showAllItems &&\n      !allowsEmptyCollection &&\n      triggerState.isOpen &&\n      filteredCollection.size === 0\n    ) {\n      triggerState.close();\n    }\n\n    // Close when an item is selected.\n    if (\n      selectedKey != null &&\n      selectedKey !== lastSelectedKey.current\n    ) {\n      triggerState.close();\n    }\n\n    // Clear focused key when input value changes and display filtered collection again.\n    if (inputValue !== lastValue.current) {\n      selectionManager.setFocusedKey(null);\n      setShowAllItems(false);\n\n      // Set selectedKey to null when the user clears the input.\n      // If controlled, this is the application developer's responsibility.\n      if (inputValue === '' && (props.inputValue === undefined || props.selectedKey === undefined)) {\n        setSelectedKey(null);\n      }\n    }\n\n    // If it is the intial render and inputValue isn't controlled nor has an intial value, set input to match current selected key if any\n    if (isInitialRender.current && (props.inputValue === undefined && props.defaultInputValue === undefined)) {\n      resetInputValue();\n    }\n\n    // If the selectedKey changed, update the input value.\n    // Do nothing if both inputValue and selectedKey are controlled.\n    // In this case, it's the user's responsibility to update inputValue in onSelectionChange.\n    if (\n      selectedKey !== lastSelectedKey.current &&\n      (props.inputValue === undefined || props.selectedKey === undefined)\n    ) {\n      resetInputValue();\n    } else {\n      lastValue.current = inputValue;\n    }\n\n    // Update the inputValue if the selected item's text changes from its last tracked value.\n    // This is to handle cases where a selectedKey is specified but the items aren't available (async loading) or the selected item's text value updates.\n    // Only reset if the user isn't currently within the field so we don't erroneously modify user input.\n    // If inputValue is controlled, it is the user's responsibility to update the inputValue when items change.\n    let selectedItemText = collection.getItem(selectedKey)?.textValue ?? '';\n    if (!isFocused && selectedKey != null && props.inputValue === undefined && selectedKey === lastSelectedKey.current) {\n      if (lastSelectedKeyText.current !== selectedItemText) {\n        lastValue.current = selectedItemText;\n        setInputValue(selectedItemText);\n      }\n    }\n\n    isInitialRender.current = false;\n    lastSelectedKey.current = selectedKey;\n    lastSelectedKeyText.current = selectedItemText;\n  });\n\n  useEffect(() => {\n    // Reset focused key when the menu closes\n    if (!triggerState.isOpen) {\n      selectionManager.setFocusedKey(null);\n    }\n  }, [triggerState.isOpen, selectionManager]);\n\n  // Revert input value and close menu\n  let revert = () => {\n    if (allowsCustomValue && selectedKey == null) {\n      commitCustomValue();\n    } else {\n      commitSelection();\n    }\n  };\n\n  let commitCustomValue = () => {\n    lastSelectedKey.current = null;\n    setSelectedKey(null);\n    triggerState.close();\n  };\n\n  let commitSelection = () => {\n    // If multiple things are controlled, call onSelectionChange\n    if (props.selectedKey !== undefined && props.inputValue !== undefined) {\n      props.onSelectionChange(selectedKey);\n\n      // Stop menu from reopening from useEffect\n      let itemText = collection.getItem(selectedKey)?.textValue ?? '';\n      lastValue.current = itemText;\n      triggerState.close();\n    } else {\n      // If only a single aspect of combobox is controlled, reset input value and close menu for the user\n      resetInputValue();\n      triggerState.close();\n    }\n  };\n\n  let commit = () => {\n    if (triggerState.isOpen && selectionManager.focusedKey != null) {\n      // Reset inputValue and close menu here if the selected key is already the focused key. Otherwise\n      // fire onSelectionChange to allow the application to control the closing.\n      if (selectedKey === selectionManager.focusedKey) {\n        commitSelection();\n      } else {\n        setSelectedKey(selectionManager.focusedKey);\n      }\n    } else if (allowsCustomValue) {\n      commitCustomValue();\n    } else {\n      // Reset inputValue and close menu if no item is focused but user triggers a commit\n      commitSelection();\n    }\n  };\n\n  let setFocused = (isFocused: boolean) => {\n    if (isFocused) {\n      if (menuTrigger === 'focus') {\n        open(null, 'focus');\n      }\n    } else if (shouldCloseOnBlur) {\n      let itemText = collection.getItem(selectedKey)?.textValue ?? '';\n      if (allowsCustomValue && inputValue !== itemText) {\n        commitCustomValue();\n      } else {\n        commitSelection();\n      }\n    }\n\n    setFocusedState(isFocused);\n  };\n\n  return {\n    ...triggerState,\n    toggle,\n    open,\n    selectionManager,\n    selectedKey,\n    setSelectedKey,\n    disabledKeys,\n    isFocused,\n    setFocused,\n    selectedItem,\n    collection: showAllItems ? originalCollection : filteredCollection,\n    inputValue,\n    setInputValue,\n    commit,\n    revert\n  };\n}\n\nfunction filterCollection<T extends object>(collection: Collection<Node<T>>, inputValue: string, filter: FilterFn): Collection<Node<T>> {\n  return new ListCollection(filterNodes(collection, inputValue, filter));\n}\n\nfunction filterNodes<T>(nodes: Iterable<Node<T>>, inputValue: string, filter: FilterFn): Iterable<Node<T>> {\n  let filteredNode = [];\n  for (let node of nodes) {\n    if (node.type === 'section' && node.hasChildNodes) {\n      let filtered = filterNodes(node.childNodes, inputValue, filter);\n      if ([...filtered].length > 0) {\n        filteredNode.push({...node, childNodes: filtered});\n      }\n    } else if (node.type !== 'section' && filter(node.textValue, inputValue)) {\n      filteredNode.push({...node});\n    }\n  }\n  return filteredNode;\n}\n"],
  "mappings": "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",
  "names": []
}
