{
  "version": 3,
  "sources": ["dep:@radix-ui_react-toggle-group", "../../../../../node_modules/@radix-ui/react-collection/dist/packages/react/collection/src/Collection.tsx", "../../../../../node_modules/@radix-ui/react-roving-focus/dist/packages/react/roving-focus/src/RovingFocusGroup.tsx", "../../../../../node_modules/@radix-ui/react-toggle-group/dist/packages/react/toggle-group/src/ToggleGroup.tsx"],
  "sourcesContent": ["\nexport * from \"../../node_modules/@radix-ui/react-toggle-group/dist/index.module.js\"", "import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Slot } from '@radix-ui/react-slot';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\ntype SlotProps = Radix.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>\u2026</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement>;\n    itemMap: Map<React.RefObject<ItemElement>, { ref: React.RefObject<ItemElement> } & ItemData>;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <Slot ref={composedRefs}>{children}</Slot>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <Slot {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </Slot>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>(GROUP_NAME);\n\ntype ScopedProps<P> = P & { __scopeRovingFocusGroup?: Scope };\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ninterface RovingFocusGroupOptions {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   * @defaultValue ltr\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n}\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] =\n  createRovingFocusGroupContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupElement = RovingFocusGroupImplElement;\ninterface RovingFocusGroupProps extends RovingFocusGroupImplProps {}\n\nconst RovingFocusGroup = React.forwardRef<RovingFocusGroupElement, RovingFocusGroupProps>(\n  (props: ScopedProps<RovingFocusGroupProps>, forwardedRef) => {\n    return (\n      <Collection.Provider scope={props.__scopeRovingFocusGroup}>\n        <Collection.Slot scope={props.__scopeRovingFocusGroup}>\n          <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n        </Collection.Slot>\n      </Collection.Provider>\n    );\n  }\n);\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupImplElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RovingFocusGroupImplProps\n  extends Omit<PrimitiveDivProps, 'dir'>,\n    RovingFocusGroupOptions {\n  currentTabStopId?: string | null;\n  defaultCurrentTabStopId?: string;\n  onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n  onEntryFocus?: (event: Event) => void;\n}\n\nconst RovingFocusGroupImpl = React.forwardRef<\n  RovingFocusGroupImplElement,\n  RovingFocusGroupImplProps\n>((props: ScopedProps<RovingFocusGroupImplProps>, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    dir = 'ltr',\n    loop = false,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<RovingFocusGroupImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      scope={__scopeRovingFocusGroup}\n      orientation={orientation}\n      dir={dir}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      )}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n    >\n      <Primitive.div\n        tabIndex={isTabbingBackOut ? -1 : 0}\n        data-orientation={orientation}\n        {...groupProps}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new Event(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusGroupItem';\n\ntype RovingFocusItemElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface RovingFocusItemProps extends PrimitiveSpanProps {\n  focusable?: boolean;\n  active?: boolean;\n}\n\nconst RovingFocusGroupItem = React.forwardRef<RovingFocusItemElement, RovingFocusItemProps>(\n  (props: ScopedProps<RovingFocusItemProps>, forwardedRef) => {\n    const { __scopeRovingFocusGroup, focusable = true, active = false, ...itemProps } = props;\n    const id = useId();\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeRovingFocusGroup}\n        id={id}\n        focusable={focusable}\n        active={active}\n      >\n        <Primitive.span\n          tabIndex={isCurrentTabStop ? 0 : -1}\n          data-orientation={context.orientation}\n          {...itemProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault();\n            // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Tab' && event.shiftKey) {\n              context.onItemShiftTab();\n              return;\n            }\n\n            if (event.target !== event.currentTarget) return;\n\n            const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n            if (focusIntent !== undefined) {\n              event.preventDefault();\n              const items = getItems().filter((item) => item.focusable);\n              let candidateNodes = items.map((item) => item.ref.current!);\n\n              if (focusIntent === 'last') candidateNodes.reverse();\n              else if (focusIntent === 'prev' || focusIntent === 'next') {\n                if (focusIntent === 'prev') candidateNodes.reverse();\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = context.loop\n                  ? wrapArray(candidateNodes, currentIndex + 1)\n                  : candidateNodes.slice(currentIndex + 1);\n              }\n\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n            }\n          })}\n        />\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nRovingFocusGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusGroupItem;\n\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupProps, RovingFocusItemProps };\n", "import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { Toggle } from '@radix-ui/react-toggle';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * ToggleGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOGGLE_GROUP_NAME = 'ToggleGroup';\n\ntype ScopedProps<P> = P & { __scopeToggleGroup?: Scope };\nconst [createToggleGroupContext, createToggleGroupScope] = createContextScope(TOGGLE_GROUP_NAME, [\n  createRovingFocusGroupScope,\n]);\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\ntype ToggleGroupElement = ToggleGroupImplSingleElement | ToggleGroupImplMultipleElement;\ninterface ToggleGroupSingleProps extends ToggleGroupImplSingleProps {\n  type: 'single';\n}\ninterface ToggleGroupMultipleProps extends ToggleGroupImplMultipleProps {\n  type: 'multiple';\n}\n\nconst ToggleGroup = React.forwardRef<\n  ToggleGroupElement,\n  ToggleGroupSingleProps | ToggleGroupMultipleProps\n>((props, forwardedRef) => {\n  const { type, ...toggleGroupProps } = props;\n\n  if (type === 'single') {\n    const singleProps = toggleGroupProps as ToggleGroupImplSingleProps;\n    return <ToggleGroupImplSingle {...singleProps} ref={forwardedRef} />;\n  }\n\n  if (type === 'multiple') {\n    const multipleProps = toggleGroupProps as ToggleGroupImplMultipleProps;\n    return <ToggleGroupImplMultiple {...multipleProps} ref={forwardedRef} />;\n  }\n\n  throw new Error(`Missing prop \\`type\\` expected on \\`${TOGGLE_GROUP_NAME}\\``);\n});\n\nToggleGroup.displayName = TOGGLE_GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ToggleGroupValueContextValue = {\n  type: 'single' | 'multiple';\n  value: string[];\n  onItemActivate(value: string): void;\n  onItemDeactivate(value: string): void;\n};\n\nconst [ToggleGroupValueProvider, useToggleGroupValueContext] =\n  createToggleGroupContext<ToggleGroupValueContextValue>(TOGGLE_GROUP_NAME);\n\ntype ToggleGroupImplSingleElement = ToggleGroupImplElement;\ninterface ToggleGroupImplSingleProps extends ToggleGroupImplProps {\n  /**\n   * The controlled stateful value of the item that is pressed.\n   */\n  value?: string;\n  /**\n   * The value of the item that is pressed when initially rendered. Use\n   * `defaultValue` if you do not need to control the state of a toggle group.\n   */\n  defaultValue?: string;\n  /**\n   * The callback that fires when the value of the toggle group changes.\n   */\n  onValueChange?(value: string): void;\n}\n\nconst ToggleGroupImplSingle = React.forwardRef<\n  ToggleGroupImplSingleElement,\n  ToggleGroupImplSingleProps\n>((props: ScopedProps<ToggleGroupImplSingleProps>, forwardedRef) => {\n  const {\n    value: valueProp,\n    defaultValue,\n    onValueChange = () => {},\n    ...toggleGroupSingleProps\n  } = props;\n\n  const [value, setValue] = useControllableState({\n    prop: valueProp,\n    defaultProp: defaultValue,\n    onChange: onValueChange,\n  });\n\n  return (\n    <ToggleGroupValueProvider\n      scope={props.__scopeToggleGroup}\n      type=\"single\"\n      value={value ? [value] : []}\n      onItemActivate={setValue}\n      onItemDeactivate={React.useCallback(() => setValue(''), [setValue])}\n    >\n      <ToggleGroupImpl {...toggleGroupSingleProps} ref={forwardedRef} />\n    </ToggleGroupValueProvider>\n  );\n});\n\ntype ToggleGroupImplMultipleElement = ToggleGroupImplElement;\ninterface ToggleGroupImplMultipleProps extends ToggleGroupImplProps {\n  /**\n   * The controlled stateful value of the items that are pressed.\n   */\n  value?: string[];\n  /**\n   * The value of the items that are pressed when initially rendered. Use\n   * `defaultValue` if you do not need to control the state of a toggle group.\n   */\n  defaultValue?: string[];\n  /**\n   * The callback that fires when the state of the toggle group changes.\n   */\n  onValueChange?(value: string[]): void;\n}\n\nconst ToggleGroupImplMultiple = React.forwardRef<\n  ToggleGroupImplMultipleElement,\n  ToggleGroupImplMultipleProps\n>((props: ScopedProps<ToggleGroupImplMultipleProps>, forwardedRef) => {\n  const {\n    value: valueProp,\n    defaultValue,\n    onValueChange = () => {},\n    ...toggleGroupMultipleProps\n  } = props;\n\n  const [value = [], setValue] = useControllableState({\n    prop: valueProp,\n    defaultProp: defaultValue,\n    onChange: onValueChange,\n  });\n\n  const handleButtonActivate = React.useCallback(\n    (itemValue) => setValue((prevValue = []) => [...prevValue, itemValue]),\n    [setValue]\n  );\n\n  const handleButtonDeactivate = React.useCallback(\n    (itemValue) => setValue((prevValue = []) => prevValue.filter((value) => value !== itemValue)),\n    [setValue]\n  );\n\n  return (\n    <ToggleGroupValueProvider\n      scope={props.__scopeToggleGroup}\n      type=\"multiple\"\n      value={value}\n      onItemActivate={handleButtonActivate}\n      onItemDeactivate={handleButtonDeactivate}\n    >\n      <ToggleGroupImpl {...toggleGroupMultipleProps} ref={forwardedRef} />\n    </ToggleGroupValueProvider>\n  );\n});\n\nToggleGroup.displayName = TOGGLE_GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ToggleGroupContextValue = { rovingFocus: boolean; disabled: boolean };\n\nconst [ToggleGroupContext, useToggleGroupContext] =\n  createToggleGroupContext<ToggleGroupContextValue>(TOGGLE_GROUP_NAME);\n\ntype RovingFocusGroupProps = Radix.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype ToggleGroupImplElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ToggleGroupImplProps extends PrimitiveDivProps {\n  /**\n   * Whether the group is disabled from user interaction.\n   * @defaultValue false\n   */\n  disabled?: boolean;\n  /**\n   * Whether the group should maintain roving focus of its buttons.\n   * @defaultValue true\n   */\n  rovingFocus?: boolean;\n  loop?: RovingFocusGroupProps['loop'];\n  orientation?: RovingFocusGroupProps['orientation'];\n  dir?: RovingFocusGroupProps['dir'];\n}\n\nconst ToggleGroupImpl = React.forwardRef<ToggleGroupImplElement, ToggleGroupImplProps>(\n  (props: ScopedProps<ToggleGroupImplProps>, forwardedRef) => {\n    const {\n      __scopeToggleGroup,\n      disabled = false,\n      rovingFocus = true,\n      orientation,\n      dir = 'ltr',\n      loop = true,\n      ...toggleGroupProps\n    } = props;\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeToggleGroup);\n    const commonProps = { role: 'group', dir, ...toggleGroupProps };\n    return (\n      <ToggleGroupContext scope={__scopeToggleGroup} rovingFocus={rovingFocus} disabled={disabled}>\n        {rovingFocus ? (\n          <RovingFocusGroup.Root\n            asChild\n            {...rovingFocusGroupScope}\n            orientation={orientation}\n            dir={dir}\n            loop={loop}\n          >\n            <Primitive.div {...commonProps} ref={forwardedRef} />\n          </RovingFocusGroup.Root>\n        ) : (\n          <Primitive.div {...commonProps} ref={forwardedRef} />\n        )}\n      </ToggleGroupContext>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * ToggleGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'ToggleGroupItem';\n\ntype ToggleGroupItemElement = ToggleGroupItemImplElement;\ninterface ToggleGroupItemProps extends Omit<ToggleGroupItemImplProps, 'pressed'> {}\n\nconst ToggleGroupItem = React.forwardRef<ToggleGroupItemElement, ToggleGroupItemProps>(\n  (props: ScopedProps<ToggleGroupItemProps>, forwardedRef) => {\n    const valueContext = useToggleGroupValueContext(ITEM_NAME, props.__scopeToggleGroup);\n    const context = useToggleGroupContext(ITEM_NAME, props.__scopeToggleGroup);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(props.__scopeToggleGroup);\n    const pressed = valueContext.value.includes(props.value);\n    const disabled = context.disabled || props.disabled;\n    const commonProps = { ...props, pressed, disabled };\n    const ref = React.useRef<HTMLDivElement>(null);\n    return context.rovingFocus ? (\n      <RovingFocusGroup.Item\n        asChild\n        {...rovingFocusGroupScope}\n        focusable={!disabled}\n        active={pressed}\n        ref={ref}\n      >\n        <ToggleGroupItemImpl {...commonProps} ref={forwardedRef} />\n      </RovingFocusGroup.Item>\n    ) : (\n      <ToggleGroupItemImpl {...commonProps} ref={forwardedRef} />\n    );\n  }\n);\n\nToggleGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ToggleGroupItemImplElement = React.ElementRef<typeof Toggle>;\ntype ToggleProps = Radix.ComponentPropsWithoutRef<typeof Toggle>;\ninterface ToggleGroupItemImplProps extends Omit<ToggleProps, 'defaultPressed' | 'onPressedChange'> {\n  /**\n   * A string value for the toggle group item. All items within a toggle group should use a unique value.\n   */\n  value: string;\n}\n\nconst ToggleGroupItemImpl = React.forwardRef<ToggleGroupItemImplElement, ToggleGroupItemImplProps>(\n  (props: ScopedProps<ToggleGroupItemImplProps>, forwardedRef) => {\n    const { __scopeToggleGroup, value, ...itemProps } = props;\n    const valueContext = useToggleGroupValueContext(ITEM_NAME, __scopeToggleGroup);\n    const singleProps = { role: 'radio', 'aria-checked': props.pressed, 'aria-pressed': undefined };\n    const typeProps = valueContext.type === 'single' ? singleProps : undefined;\n    return (\n      <Toggle\n        {...typeProps}\n        {...itemProps}\n        ref={forwardedRef}\n        onPressedChange={(pressed) => {\n          if (pressed) {\n            valueContext.onItemActivate(value);\n          } else {\n            valueContext.onItemDeactivate(value);\n          }\n        }}\n      />\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = ToggleGroup;\nconst Item = ToggleGroupItem;\n\nexport {\n  createToggleGroupScope,\n  //\n  ToggleGroup,\n  ToggleGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { ToggleGroupSingleProps, ToggleGroupMultipleProps, ToggleGroupItemProps };\n"],
  "mappings": "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",
  "names": []
}
