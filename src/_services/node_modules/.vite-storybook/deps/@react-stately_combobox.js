import {
  $fc909762b330b746$export$61c6a8c84e605fb6
} from "./chunk-TSGJN5Z3.js";
import {
  $458b0a5536c1a7cf$export$40bfa8c7b0832715
} from "./chunk-M2VHT2SL.js";
import {
  $7613b1592d41b092$export$6cd28814d92fa9c9
} from "./chunk-DXCSNBCS.js";
import {
  require_react
} from "./chunk-TW7ERABM.js";
import "./chunk-ONM5EPDC.js";
import {
  __toESM,
  init_define_import_meta_env
} from "./chunk-CCD2FOVN.js";

// dep:@react-stately_combobox
init_define_import_meta_env();

// node_modules/@react-stately/combobox/dist/module.js
init_define_import_meta_env();

// node_modules/@react-stately/list/dist/module.js
init_define_import_meta_env();
var import_react2 = __toESM(require_react());

// node_modules/@react-stately/selection/dist/module.js
init_define_import_meta_env();
var import_react = __toESM(require_react());
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
}
var $7af3f5b51489e0b5$exports = {};
$parcel$export($7af3f5b51489e0b5$exports, "useMultipleSelectionState", () => $7af3f5b51489e0b5$export$253fe78d46329472);
var $e40ea825a81a3709$export$52baac22726c72bf = class extends Set {
  constructor(keys, anchorKey, currentKey) {
    super(keys);
    if (keys instanceof $e40ea825a81a3709$export$52baac22726c72bf) {
      this.anchorKey = anchorKey || keys.anchorKey;
      this.currentKey = currentKey || keys.currentKey;
    } else {
      this.anchorKey = anchorKey;
      this.currentKey = currentKey;
    }
  }
};
function $7af3f5b51489e0b5$var$equalSets(setA, setB) {
  if (setA.size !== setB.size)
    return false;
  for (let item of setA) {
    if (!setB.has(item))
      return false;
  }
  return true;
}
function $7af3f5b51489e0b5$export$253fe78d46329472(props) {
  let { selectionMode = "none", disallowEmptySelection, allowDuplicateSelectionEvents, selectionBehavior: selectionBehaviorProp = "toggle", disabledBehavior = "all" } = props;
  let isFocusedRef = (0, import_react.useRef)(false);
  let [, setFocused] = (0, import_react.useState)(false);
  let focusedKeyRef = (0, import_react.useRef)(null);
  let childFocusStrategyRef = (0, import_react.useRef)(null);
  let [, setFocusedKey] = (0, import_react.useState)(null);
  let selectedKeysProp = (0, import_react.useMemo)(() => $7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [
    props.selectedKeys
  ]);
  let defaultSelectedKeys = (0, import_react.useMemo)(() => $7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new $e40ea825a81a3709$export$52baac22726c72bf()), [
    props.defaultSelectedKeys
  ]);
  let [selectedKeys, setSelectedKeys] = $458b0a5536c1a7cf$export$40bfa8c7b0832715(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);
  let disabledKeysProp = (0, import_react.useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : /* @__PURE__ */ new Set(), [
    props.disabledKeys
  ]);
  let [selectionBehavior, setSelectionBehavior] = (0, import_react.useState)(selectionBehaviorProp);
  if (selectionBehaviorProp === "replace" && selectionBehavior === "toggle" && typeof selectedKeys === "object" && selectedKeys.size === 0)
    setSelectionBehavior("replace");
  let lastSelectionBehavior = (0, import_react.useRef)(selectionBehaviorProp);
  (0, import_react.useEffect)(() => {
    if (selectionBehaviorProp !== lastSelectionBehavior.current) {
      setSelectionBehavior(selectionBehaviorProp);
      lastSelectionBehavior.current = selectionBehaviorProp;
    }
  }, [
    selectionBehaviorProp
  ]);
  return {
    selectionMode,
    disallowEmptySelection,
    selectionBehavior,
    setSelectionBehavior,
    get isFocused() {
      return isFocusedRef.current;
    },
    setFocused(f) {
      isFocusedRef.current = f;
      setFocused(f);
    },
    get focusedKey() {
      return focusedKeyRef.current;
    },
    get childFocusStrategy() {
      return childFocusStrategyRef.current;
    },
    setFocusedKey(k, childFocusStrategy = "first") {
      focusedKeyRef.current = k;
      childFocusStrategyRef.current = childFocusStrategy;
      setFocusedKey(k);
    },
    selectedKeys,
    setSelectedKeys(keys) {
      if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys, selectedKeys))
        setSelectedKeys(keys);
    },
    disabledKeys: disabledKeysProp,
    disabledBehavior
  };
}
function $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {
  if (!selection)
    return defaultValue;
  return selection === "all" ? "all" : new $e40ea825a81a3709$export$52baac22726c72bf(selection);
}
var $d496c0a20b6e58ec$exports = {};
$parcel$export($d496c0a20b6e58ec$exports, "SelectionManager", () => $d496c0a20b6e58ec$export$6c8a5aaad13c9852);
var $d496c0a20b6e58ec$export$6c8a5aaad13c9852 = class {
  get selectionMode() {
    return this.state.selectionMode;
  }
  get disallowEmptySelection() {
    return this.state.disallowEmptySelection;
  }
  get selectionBehavior() {
    return this.state.selectionBehavior;
  }
  setSelectionBehavior(selectionBehavior) {
    this.state.setSelectionBehavior(selectionBehavior);
  }
  get isFocused() {
    return this.state.isFocused;
  }
  setFocused(isFocused) {
    this.state.setFocused(isFocused);
  }
  get focusedKey() {
    return this.state.focusedKey;
  }
  get childFocusStrategy() {
    return this.state.childFocusStrategy;
  }
  setFocusedKey(key, childFocusStrategy) {
    this.state.setFocusedKey(key, childFocusStrategy);
  }
  get selectedKeys() {
    return this.state.selectedKeys === "all" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;
  }
  get rawSelection() {
    return this.state.selectedKeys;
  }
  isSelected(key) {
    if (this.state.selectionMode === "none")
      return false;
    key = this.getKey(key);
    return this.state.selectedKeys === "all" ? this.canSelectItem(key) : this.state.selectedKeys.has(key);
  }
  get isEmpty() {
    return this.state.selectedKeys !== "all" && this.state.selectedKeys.size === 0;
  }
  get isSelectAll() {
    if (this.isEmpty)
      return false;
    if (this.state.selectedKeys === "all")
      return true;
    if (this._isSelectAll != null)
      return this._isSelectAll;
    let allKeys = this.getSelectAllKeys();
    let selectedKeys = this.state.selectedKeys;
    this._isSelectAll = allKeys.every((k) => selectedKeys.has(k));
    return this._isSelectAll;
  }
  get firstSelectedKey() {
    let first = null;
    for (let key of this.state.selectedKeys) {
      let item = this.collection.getItem(key);
      if (!first || (item === null || item === void 0 ? void 0 : item.index) < first.index)
        first = item;
    }
    return first === null || first === void 0 ? void 0 : first.key;
  }
  get lastSelectedKey() {
    let last = null;
    for (let key of this.state.selectedKeys) {
      let item = this.collection.getItem(key);
      if (!last || (item === null || item === void 0 ? void 0 : item.index) > last.index)
        last = item;
    }
    return last === null || last === void 0 ? void 0 : last.key;
  }
  get disabledKeys() {
    return this.state.disabledKeys;
  }
  get disabledBehavior() {
    return this.state.disabledBehavior;
  }
  extendSelection(toKey) {
    if (this.selectionMode === "none")
      return;
    if (this.selectionMode === "single") {
      this.replaceSelection(toKey);
      return;
    }
    toKey = this.getKey(toKey);
    let selection;
    if (this.state.selectedKeys === "all")
      selection = new $e40ea825a81a3709$export$52baac22726c72bf([
        toKey
      ], toKey, toKey);
    else {
      let selectedKeys = this.state.selectedKeys;
      let anchorKey = selectedKeys.anchorKey || toKey;
      selection = new $e40ea825a81a3709$export$52baac22726c72bf(selectedKeys, anchorKey, toKey);
      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey))
        selection.delete(key);
      for (let key1 of this.getKeyRange(toKey, anchorKey))
        if (this.canSelectItem(key1))
          selection.add(key1);
    }
    this.state.setSelectedKeys(selection);
  }
  getKeyRange(from, to) {
    let fromItem = this.collection.getItem(from);
    let toItem = this.collection.getItem(to);
    if (fromItem && toItem) {
      if (fromItem.index <= toItem.index)
        return this.getKeyRangeInternal(from, to);
      return this.getKeyRangeInternal(to, from);
    }
    return [];
  }
  getKeyRangeInternal(from, to) {
    let keys = [];
    let key = from;
    while (key) {
      let item = this.collection.getItem(key);
      if (item && item.type === "item" || item.type === "cell" && this.allowsCellSelection)
        keys.push(key);
      if (key === to)
        return keys;
      key = this.collection.getKeyAfter(key);
    }
    return [];
  }
  getKey(key) {
    let item = this.collection.getItem(key);
    if (!item)
      return key;
    if (item.type === "cell" && this.allowsCellSelection)
      return key;
    while (item.type !== "item" && item.parentKey != null)
      item = this.collection.getItem(item.parentKey);
    if (!item || item.type !== "item")
      return null;
    return item.key;
  }
  toggleSelection(key) {
    if (this.selectionMode === "none")
      return;
    if (this.selectionMode === "single" && !this.isSelected(key)) {
      this.replaceSelection(key);
      return;
    }
    key = this.getKey(key);
    if (key == null)
      return;
    let keys = new $e40ea825a81a3709$export$52baac22726c72bf(this.state.selectedKeys === "all" ? this.getSelectAllKeys() : this.state.selectedKeys);
    if (keys.has(key))
      keys.delete(key);
    else if (this.canSelectItem(key)) {
      keys.add(key);
      keys.anchorKey = key;
      keys.currentKey = key;
    }
    if (this.disallowEmptySelection && keys.size === 0)
      return;
    this.state.setSelectedKeys(keys);
  }
  replaceSelection(key) {
    if (this.selectionMode === "none")
      return;
    key = this.getKey(key);
    if (key == null)
      return;
    let selection = this.canSelectItem(key) ? new $e40ea825a81a3709$export$52baac22726c72bf([
      key
    ], key, key) : new $e40ea825a81a3709$export$52baac22726c72bf();
    this.state.setSelectedKeys(selection);
  }
  setSelectedKeys(keys) {
    if (this.selectionMode === "none")
      return;
    let selection = new $e40ea825a81a3709$export$52baac22726c72bf();
    for (let key of keys) {
      key = this.getKey(key);
      if (key != null) {
        selection.add(key);
        if (this.selectionMode === "single")
          break;
      }
    }
    this.state.setSelectedKeys(selection);
  }
  getSelectAllKeys() {
    let keys = [];
    let addKeys = (key) => {
      while (key) {
        if (this.canSelectItem(key)) {
          let item = this.collection.getItem(key);
          if (item.type === "item")
            keys.push(key);
          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== "item"))
            addKeys([
              ...item.childNodes
            ][0].key);
        }
        key = this.collection.getKeyAfter(key);
      }
    };
    addKeys(this.collection.getFirstKey());
    return keys;
  }
  selectAll() {
    if (this.selectionMode === "multiple")
      this.state.setSelectedKeys("all");
  }
  clearSelection() {
    if (!this.disallowEmptySelection && (this.state.selectedKeys === "all" || this.state.selectedKeys.size > 0))
      this.state.setSelectedKeys(new $e40ea825a81a3709$export$52baac22726c72bf());
  }
  toggleSelectAll() {
    if (this.isSelectAll)
      this.clearSelection();
    else
      this.selectAll();
  }
  select(key, e) {
    if (this.selectionMode === "none")
      return;
    if (this.selectionMode === "single") {
      if (this.isSelected(key) && !this.disallowEmptySelection)
        this.toggleSelection(key);
      else
        this.replaceSelection(key);
    } else if (this.selectionBehavior === "toggle" || e && (e.pointerType === "touch" || e.pointerType === "virtual"))
      this.toggleSelection(key);
    else
      this.replaceSelection(key);
  }
  isSelectionEqual(selection) {
    if (selection === this.state.selectedKeys)
      return true;
    let selectedKeys = this.selectedKeys;
    if (selection.size !== selectedKeys.size)
      return false;
    for (let key of selection) {
      if (!selectedKeys.has(key))
        return false;
    }
    for (let key2 of selectedKeys) {
      if (!selection.has(key2))
        return false;
    }
    return true;
  }
  canSelectItem(key) {
    if (this.state.selectionMode === "none" || this.state.disabledKeys.has(key))
      return false;
    let item = this.collection.getItem(key);
    if (!item || item.type === "cell" && !this.allowsCellSelection)
      return false;
    return true;
  }
  isDisabled(key) {
    return this.state.disabledKeys.has(key) && this.state.disabledBehavior === "all";
  }
  constructor(collection, state, options) {
    this.collection = collection;
    this.state = state;
    var ref;
    this.allowsCellSelection = (ref = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && ref !== void 0 ? ref : false;
    this._isSelectAll = null;
  }
};

// node_modules/@react-stately/list/dist/module.js
function $parcel$export2(e, n, v, s) {
  Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
}
var $e72dd72e1c76a225$exports = {};
$parcel$export2($e72dd72e1c76a225$exports, "useListState", () => $e72dd72e1c76a225$export$2f645645f7bca764);
var $a02d57049d202695$exports = {};
$parcel$export2($a02d57049d202695$exports, "ListCollection", () => $a02d57049d202695$export$d085fb9e920b5ca7);
var tmp = Symbol.iterator;
var $a02d57049d202695$export$d085fb9e920b5ca7 = class {
  *[tmp]() {
    yield* this.iterable;
  }
  get size() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key) {
    let node = this.keyMap.get(key);
    return node ? node.prevKey : null;
  }
  getKeyAfter(key) {
    let node = this.keyMap.get(key);
    return node ? node.nextKey : null;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(key) {
    return this.keyMap.get(key);
  }
  at(idx) {
    const keys = [
      ...this.getKeys()
    ];
    return this.getItem(keys[idx]);
  }
  constructor(nodes) {
    this.keyMap = /* @__PURE__ */ new Map();
    this.iterable = nodes;
    let visit = (node) => {
      this.keyMap.set(node.key, node);
      if (node.childNodes && node.type === "section")
        for (let child of node.childNodes)
          visit(child);
    };
    for (let node2 of nodes)
      visit(node2);
    let last;
    let index = 0;
    for (let [key, node1] of this.keyMap) {
      if (last) {
        last.nextKey = key;
        node1.prevKey = last.key;
      } else {
        this.firstKey = key;
        node1.prevKey = void 0;
      }
      if (node1.type === "item")
        node1.index = index++;
      last = node1;
      last.nextKey = void 0;
    }
    this.lastKey = last === null || last === void 0 ? void 0 : last.key;
  }
};
function $e72dd72e1c76a225$export$2f645645f7bca764(props) {
  let { filter } = props;
  let selectionState = $7af3f5b51489e0b5$export$253fe78d46329472(props);
  let disabledKeys = (0, import_react2.useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : /* @__PURE__ */ new Set(), [
    props.disabledKeys
  ]);
  let factory = (nodes) => filter ? new $a02d57049d202695$export$d085fb9e920b5ca7(filter(nodes)) : new $a02d57049d202695$export$d085fb9e920b5ca7(nodes);
  let context = (0, import_react2.useMemo)(() => ({
    suppressTextValueWarning: props.suppressTextValueWarning
  }), [
    props.suppressTextValueWarning
  ]);
  let collection = $7613b1592d41b092$export$6cd28814d92fa9c9(props, factory, context, [
    filter
  ]);
  (0, import_react2.useEffect)(() => {
    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey))
      selectionState.setFocusedKey(null);
  }, [
    collection,
    selectionState.focusedKey
  ]);
  return {
    collection,
    disabledKeys,
    selectionManager: new $d496c0a20b6e58ec$export$6c8a5aaad13c9852(collection, selectionState)
  };
}
var $a0d645289fe9b86b$exports = {};
$parcel$export2($a0d645289fe9b86b$exports, "useSingleSelectListState", () => $a0d645289fe9b86b$export$e7f05e985daf4b5f);
function $a0d645289fe9b86b$export$e7f05e985daf4b5f(props) {
  var _defaultSelectedKey;
  let [selectedKey, setSelectedKey] = $458b0a5536c1a7cf$export$40bfa8c7b0832715(props.selectedKey, (_defaultSelectedKey = props.defaultSelectedKey) !== null && _defaultSelectedKey !== void 0 ? _defaultSelectedKey : null, props.onSelectionChange);
  let selectedKeys = (0, import_react2.useMemo)(() => selectedKey != null ? [
    selectedKey
  ] : [], [
    selectedKey
  ]);
  let { collection, disabledKeys, selectionManager } = $e72dd72e1c76a225$export$2f645645f7bca764({
    ...props,
    selectionMode: "single",
    disallowEmptySelection: true,
    allowDuplicateSelectionEvents: true,
    selectedKeys,
    onSelectionChange: (keys) => {
      let key = keys.values().next().value;
      if (key === selectedKey && props.onSelectionChange)
        props.onSelectionChange(key);
      setSelectedKey(key);
    }
  });
  let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : null;
  return {
    collection,
    disabledKeys,
    selectionManager,
    selectedKey,
    setSelectedKey,
    selectedItem
  };
}

// node_modules/@react-stately/combobox/dist/module.js
var import_react4 = __toESM(require_react());

// node_modules/@react-stately/menu/dist/module.js
init_define_import_meta_env();
var import_react3 = __toESM(require_react());
function $parcel$export3(e, n, v, s) {
  Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
}
var $a28c903ee9ad8dc5$exports = {};
$parcel$export3($a28c903ee9ad8dc5$exports, "useMenuTriggerState", () => $a28c903ee9ad8dc5$export$79fefeb1c2091ac3);
function $a28c903ee9ad8dc5$export$79fefeb1c2091ac3(props) {
  let overlayTriggerState = $fc909762b330b746$export$61c6a8c84e605fb6(props);
  let [focusStrategy1, setFocusStrategy] = (0, import_react3.useState)(null);
  return {
    focusStrategy: focusStrategy1,
    ...overlayTriggerState,
    open(focusStrategy = null) {
      setFocusStrategy(focusStrategy);
      overlayTriggerState.open();
    },
    toggle(focusStrategy = null) {
      setFocusStrategy(focusStrategy);
      overlayTriggerState.toggle();
    }
  };
}

// node_modules/@react-stately/combobox/dist/module.js
function $parcel$export4(e, n, v, s) {
  Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
}
var $a9e7382a7d111cb5$exports = {};
$parcel$export4($a9e7382a7d111cb5$exports, "useComboBoxState", () => $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e);
function $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e(props) {
  var ref4;
  let { defaultFilter, menuTrigger = "input", allowsEmptyCollection = false, allowsCustomValue, shouldCloseOnBlur = true } = props;
  let [showAllItems, setShowAllItems] = (0, import_react4.useState)(false);
  let [isFocused1, setFocusedState] = (0, import_react4.useState)(false);
  var _defaultInputValue;
  let [inputValue, setInputValue] = $458b0a5536c1a7cf$export$40bfa8c7b0832715(props.inputValue, (_defaultInputValue = props.defaultInputValue) !== null && _defaultInputValue !== void 0 ? _defaultInputValue : "", props.onInputChange);
  let onSelectionChange = (key) => {
    if (props.onSelectionChange)
      props.onSelectionChange(key);
    if (key === selectedKey) {
      resetInputValue();
      triggerState.close();
    }
  };
  var _items;
  let { collection, selectionManager, selectedKey, setSelectedKey, selectedItem, disabledKeys } = $a0d645289fe9b86b$export$e7f05e985daf4b5f({
    ...props,
    onSelectionChange,
    items: (_items = props.items) !== null && _items !== void 0 ? _items : props.defaultItems
  });
  let originalCollection = collection;
  let filteredCollection = (0, import_react4.useMemo)(() => props.items != null || !defaultFilter ? collection : $a9e7382a7d111cb5$var$filterCollection(collection, inputValue, defaultFilter), [
    collection,
    inputValue,
    defaultFilter,
    props.items
  ]);
  let menuOpenTrigger = (0, import_react4.useRef)("focus");
  let onOpenChange = (open) => {
    if (props.onOpenChange)
      props.onOpenChange(open, open ? menuOpenTrigger.current : void 0);
  };
  let triggerState = $a28c903ee9ad8dc5$export$79fefeb1c2091ac3({
    ...props,
    onOpenChange,
    isOpen: void 0,
    defaultOpen: void 0
  });
  let open1 = (focusStrategy, trigger) => {
    let displayAllItems = trigger === "manual" || trigger === "focus" && menuTrigger === "focus";
    if (allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) {
      if (displayAllItems && !triggerState.isOpen && props.items === void 0)
        setShowAllItems(true);
      menuOpenTrigger.current = trigger;
      triggerState.open(focusStrategy);
    }
  };
  let toggle = (focusStrategy, trigger) => {
    let displayAllItems = trigger === "manual" || trigger === "focus" && menuTrigger === "focus";
    if (!(allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) && !triggerState.isOpen)
      return;
    if (displayAllItems && !triggerState.isOpen && props.items === void 0)
      setShowAllItems(true);
    if (!triggerState.isOpen)
      menuOpenTrigger.current = trigger;
    triggerState.toggle(focusStrategy);
  };
  let lastValue = (0, import_react4.useRef)(inputValue);
  let resetInputValue = () => {
    var ref;
    var ref3;
    let itemText = (ref3 = (ref = collection.getItem(selectedKey)) === null || ref === void 0 ? void 0 : ref.textValue) !== null && ref3 !== void 0 ? ref3 : "";
    lastValue.current = itemText;
    setInputValue(itemText);
  };
  let isInitialRender = (0, import_react4.useRef)(true);
  var _selectedKey, ref1;
  let lastSelectedKey = (0, import_react4.useRef)((ref1 = (_selectedKey = props.selectedKey) !== null && _selectedKey !== void 0 ? _selectedKey : props.defaultSelectedKey) !== null && ref1 !== void 0 ? ref1 : null);
  var ref2;
  let lastSelectedKeyText = (0, import_react4.useRef)((ref2 = (ref4 = collection.getItem(selectedKey)) === null || ref4 === void 0 ? void 0 : ref4.textValue) !== null && ref2 !== void 0 ? ref2 : "");
  (0, import_react4.useEffect)(() => {
    var ref;
    if (isFocused1 && (filteredCollection.size > 0 || allowsEmptyCollection) && !triggerState.isOpen && inputValue !== lastValue.current && menuTrigger !== "manual")
      open1(null, "input");
    if (!showAllItems && !allowsEmptyCollection && triggerState.isOpen && filteredCollection.size === 0)
      triggerState.close();
    if (selectedKey != null && selectedKey !== lastSelectedKey.current)
      triggerState.close();
    if (inputValue !== lastValue.current) {
      selectionManager.setFocusedKey(null);
      setShowAllItems(false);
      if (inputValue === "" && (props.inputValue === void 0 || props.selectedKey === void 0))
        setSelectedKey(null);
    }
    if (isInitialRender.current && props.inputValue === void 0 && props.defaultInputValue === void 0)
      resetInputValue();
    if (selectedKey !== lastSelectedKey.current && (props.inputValue === void 0 || props.selectedKey === void 0))
      resetInputValue();
    else
      lastValue.current = inputValue;
    var ref5;
    let selectedItemText = (ref5 = (ref = collection.getItem(selectedKey)) === null || ref === void 0 ? void 0 : ref.textValue) !== null && ref5 !== void 0 ? ref5 : "";
    if (!isFocused1 && selectedKey != null && props.inputValue === void 0 && selectedKey === lastSelectedKey.current) {
      if (lastSelectedKeyText.current !== selectedItemText) {
        lastValue.current = selectedItemText;
        setInputValue(selectedItemText);
      }
    }
    isInitialRender.current = false;
    lastSelectedKey.current = selectedKey;
    lastSelectedKeyText.current = selectedItemText;
  });
  (0, import_react4.useEffect)(() => {
    if (!triggerState.isOpen)
      selectionManager.setFocusedKey(null);
  }, [
    triggerState.isOpen,
    selectionManager
  ]);
  let revert = () => {
    if (allowsCustomValue && selectedKey == null)
      commitCustomValue();
    else
      commitSelection();
  };
  let commitCustomValue = () => {
    lastSelectedKey.current = null;
    setSelectedKey(null);
    triggerState.close();
  };
  let commitSelection = () => {
    if (props.selectedKey !== void 0 && props.inputValue !== void 0) {
      var ref;
      props.onSelectionChange(selectedKey);
      var ref6;
      let itemText = (ref6 = (ref = collection.getItem(selectedKey)) === null || ref === void 0 ? void 0 : ref.textValue) !== null && ref6 !== void 0 ? ref6 : "";
      lastValue.current = itemText;
      triggerState.close();
    } else {
      resetInputValue();
      triggerState.close();
    }
  };
  let commit = () => {
    if (triggerState.isOpen && selectionManager.focusedKey != null) {
      if (selectedKey === selectionManager.focusedKey)
        commitSelection();
      else
        setSelectedKey(selectionManager.focusedKey);
    } else if (allowsCustomValue)
      commitCustomValue();
    else
      commitSelection();
  };
  let setFocused = (isFocused) => {
    if (isFocused) {
      if (menuTrigger === "focus")
        open1(null, "focus");
    } else if (shouldCloseOnBlur) {
      var ref;
      var ref7;
      let itemText = (ref7 = (ref = collection.getItem(selectedKey)) === null || ref === void 0 ? void 0 : ref.textValue) !== null && ref7 !== void 0 ? ref7 : "";
      if (allowsCustomValue && inputValue !== itemText)
        commitCustomValue();
      else
        commitSelection();
    }
    setFocusedState(isFocused);
  };
  return {
    ...triggerState,
    toggle,
    open: open1,
    selectionManager,
    selectedKey,
    setSelectedKey,
    disabledKeys,
    isFocused: isFocused1,
    setFocused,
    selectedItem,
    collection: showAllItems ? originalCollection : filteredCollection,
    inputValue,
    setInputValue,
    commit,
    revert
  };
}
function $a9e7382a7d111cb5$var$filterCollection(collection, inputValue, filter) {
  return new $a02d57049d202695$export$d085fb9e920b5ca7($a9e7382a7d111cb5$var$filterNodes(collection, inputValue, filter));
}
function $a9e7382a7d111cb5$var$filterNodes(nodes, inputValue, filter) {
  let filteredNode = [];
  for (let node of nodes) {
    if (node.type === "section" && node.hasChildNodes) {
      let filtered = $a9e7382a7d111cb5$var$filterNodes(node.childNodes, inputValue, filter);
      if ([
        ...filtered
      ].length > 0)
        filteredNode.push({
          ...node,
          childNodes: filtered
        });
    } else if (node.type !== "section" && filter(node.textValue, inputValue))
      filteredNode.push({
        ...node
      });
  }
  return filteredNode;
}
export {
  $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e as useComboBoxState
};
//# sourceMappingURL=@react-stately_combobox.js.map
